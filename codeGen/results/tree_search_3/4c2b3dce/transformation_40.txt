===BEGIN PLAN===
Check if the string can be divided into two non-overlapping parts, each containing one of 'A' or 'B', and then check if these parts contain the required substrings.

The state is a tuple containing the counts of 'A' and 'B' in the current substring, as well as a flag indicating whether 'AB' has been found yet.
State: (a, b) where a is the count of 'A', b is the count of 'B', and both are non-negative integers.

Initialize a dictionary dp where each key represents a state (a, b), and its value is a boolean indicating whether 'AB' has been found in that state.

For each character c in the string:
    If c is 'A':
        For each previous state (a, b) in dp:
            If (b + 1, 0) is not in dp and the substring from index 0 to i contains 'B' exactly once:
                Set dp[(b + 1, 0)] to True
    If c is 'B':
        For each previous state (a, b) in dp:
            If (a + 1, 0) is not in dp and the substring from index 0 to i contains 'A' exactly once:
                Set dp[(a + 1, 0)] to True

After processing the entire string, check if 'AB' has been found in any state. If yes, return "YES", otherwise return "NO".

This plan correctly solves the problem and handles all edge cases. The dynamic programming approach ensures that we only need to consider each substring once, which reduces the time complexity to O(n), where n is the length of the string.
===END PLAN===
