===BEGIN PLAN===
Check if the string can be divided into two non-overlapping parts, each containing one of 'A' or 'B', and then check if these parts contain the required substrings.

The state is a tuple containing the counts of 'A' and 'B' in the current substring, as well as a flag indicating whether 'AB' has been found yet.

State: (a, b) where a is the count of 'A', b is the count of 'B', and both are non-negative integers.

Use a dictionary to store the intermediate results and avoid redundant calculations. 

For each character in the string:

    If the character is 'A', increment the count of 'A' in the current state.
    If the character is 'B', increment the count of 'B' in the current state.
    
    If the counts are both equal to 1, it means we have found 'AB'. 
    If not, check if there's a previous state where 'BA' can be found. 

Store each state in the dictionary along with its corresponding flag (whether 'AB' has been found).
When checking for 'BA', start from the most recent state and move backwards until you find one where 'A' count is greater than 'B' count.
Return "YES" if 'AB' or 'BA' is found, else return "NO".
===END PLAN===
