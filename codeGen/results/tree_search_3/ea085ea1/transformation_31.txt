===BEGIN FEEDBACK===
Your plan is generally correct, but there are a few potential issues to consider.

Firstly, the state expression you defined is correct: (i, j) represents the maximum number of common non-overlapping substrings between str1[:i] and str2[:j].

However, I think your memoization approach might not be optimal. You mentioned filling up a table by iterating over all possible substrings and checking if they are present in both input strings. This could lead to an exponential time complexity due to the number of substrings considered.

To improve this, you could consider using a more efficient data structure to store the count of common non-overlapping substrings for each prefix of str1 and str2. For example, you could use a dictionary where the keys are tuples representing the current prefixes in both strings, and the values are the counts of common non-overlapping substrings.

Another issue is that your plan doesn't explicitly handle edge cases. What if one or both input strings are empty? Your base case should cover these scenarios to avoid potential errors.

Finally, you might want to consider a more efficient way to check if a substring is present in both input strings. Instead of iterating over all possible substrings and checking each one, you could use a single pass through the strings to build up a data structure (e.g., a suffix tree or a trie) that allows for fast lookup of substrings.

Overall, your plan has good intuition, but it needs refinement to handle edge cases and optimize its approach. With some modifications, I believe your plan can be effective in solving this problem.
===END FEEDBACK===
