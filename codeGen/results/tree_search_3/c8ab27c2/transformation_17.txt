===BEGIN PLAN===
Avoid overlapping subproblems by considering only unique prefixes in both strings.
Implement a recursive function with memoization using a dictionary.

// This approach makes sense as we don't want to repeat the same calculations multiple times.
// Memoization helps in reducing the time complexity of the solution.

Defining the state as the length of the longest common subsequence found so far between prefixes of S and T.
Define the state as the maximum length of uncommon subsequences found so far between prefixes of S and T.

// The state definition looks correct. We need to keep track of both the common and uncommon subsequences.

Use a dictionary to store and look up previously computed values of subsequence lengths for given prefixes.

// This is a good idea as it will help us avoid recalculating the same values multiple times.
