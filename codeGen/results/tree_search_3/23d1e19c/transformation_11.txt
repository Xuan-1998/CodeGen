===BEGIN PLAN===
Consider a dynamic programming approach where you maintain an array dp[i] that stores the minimum number of recomputations needed from vertex i to t, considering all shortest paths from i to t. The optimal substructure is when you reach vertex i, and then you need to decide whether to follow the recommended path or not.

dp[i] is 0 if vertex i is in the fixed path, and 1 + dp[v] otherwise (where v is the previous vertex in the path),

Transition: dp[i] = min(dp[j] + 1 for j in range(1, i)) if i not in fixed_path, else 0;
Use a dictionary memo to store the results of subproblems and return memo[i] if memo[i] exists.

===END PLAN===
