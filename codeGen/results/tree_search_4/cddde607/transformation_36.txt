===BEGIN PLAN===
Dynamic programming can also be used with tabulation approach where a 2D table dp[][] is filled from top-down manner with memoization to avoid overlapping sub-problems.

The state expression could be dp[i][j] = total number of ways to reach cell (i, j) regardless of the number of coins collected.
dp[i][j] should be updated based on whether it's possible to collect exactly K coins by reaching cell (i, j), considering all possible previous cells that can lead to this state.

Create a 2D table dp[][] of size N x N where each cell dp[i][j] represents the total number of ways to collect exactly K coins from cell (0, 0) to (i, j).
Fill up the dp[][] in a bottom-up manner:
- If i == 0 and j == 0, then there's only one way to reach this state (K = 0), so dp[0][0] = 1.
- For other cells, if it's possible to collect exactly K coins by reaching cell (i, j) from the top or left, update dp[i][j] accordingly.

===END PLAN===
