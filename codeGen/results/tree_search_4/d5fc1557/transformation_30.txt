===BEGIN PLAN===
Memoize the maximum length of 1's found in previous subarrays to avoid redundant computation.

Let dp[i] be the maximum length of 1's found in previous subarrays ending at index i. The state is a tuple (i, ones) where i is the current index and ones is the maximum length of 1's found in previous subarrays.

Define a function max_ones(dp, n) that calculates the maximum length of 1's found in previous subarrays for each index i from 0 to n-1. For each state (i, ones), update dp[i] with the maximum value if i > 0; Initialize dp[0] as 0.

For each state (i, ones), consider two cases:

* If nums[i] is 1, then update dp[i] with max(dp[i-1], ones+1) to keep track of the maximum length of 1's found in previous subarrays.
* If nums[i] is 0, then reset dp[i] to 0 because we can't extend the current sequence of 1's.

Create a DP table to store the maximum length of 1's found in previous subarrays for each index, and update it accordingly.

After filling up the DP table, return dp[n-1] as the result, which represents the maximum length of 1's found in the original array after deleting one element.

To find the longest subarray containing only 1's, iterate over the DP table to find the maximum value. If no such subarray is found, return 0.
===END PLAN===
