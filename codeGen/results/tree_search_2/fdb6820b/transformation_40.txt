The problem can be solved by using dynamic programming with both memoization and tabulation, where we first build a bottom-up solution table and then use this table to compute the final solution.
let dp[i] be the number of ways to form a sum less than or equal to i, and define base case as dp[0] = 1.
dp[i] = dp[i - arr[0]] * len([j for j in range(1, i) if j % arr[0] == 0]),
A tabulation-based approach that uses a list dp of size N+1, with dp[i] representing the number of ways to form a sum less than or equal to i.
