The problem can be solved by using dynamic programming with both memoization and tabulation, where we first build a bottom-up solution table and then use this table to compute the final solution.
let dp[i] be the number of ways to form a sum less than or equal to i, and define base case as dp[0] = 1.
dp[i] = sum(dp[j] for j in range(i)) if i >= max(arr), else dp[i - max(arr)] + len([j for j in range(max(arr) + 1, i) if j % max(arr) == 0])
Build a bottom-up solution table using a loop and store the intermediate results to avoid redundant computations.
