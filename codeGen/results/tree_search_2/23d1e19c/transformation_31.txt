Think about using a disjoint set data structure to keep track of connected components in the graph and update the minimum and maximum number of recomputations accordingly.
The state expression is the current vertex v, with dp[v] representing the minimum and maximum number of times the shortest path from v to t needs to be recomputed. The base case is when v equals t, where dp[t] = [0, 0].
dp[v] = [min(min(dp[p] for p in path[v]), dp[path[v]][1]) + 1, max(max(dp[p] for p in path[v]), dp[path[v]][0])], where path[v] contains all vertices from s to v.
The dynamic programming solution can involve iterating over all edges in the graph, where for each edge (u, v), if u is not equal to t, then dp[v] = min(dp[u], dp[v]) + 1 and max(dp[u], dp[v]), else dp[t] = [0, 0].
