Think about using a disjoint set data structure to keep track of connected components in the graph and update the minimum and maximum number of recomputations accordingly.
The state expression is the current vertex v, with dp[v] representing the minimum and maximum number of times the shortest path from v to t needs to be recomputed. The base case is when v equals t, where dp[t] = [0, 0].
dp[v] = [min(min(dp[p] for p in path[v]), dp[path[v]][1]) + 1, max(max(dp[p] for p in path[v]), dp[path[v]][0])], where path[v] contains all vertices from s to v.
The dynamic programming state can be represented as a table with n rows, where the i-th row corresponds to vertex i. Each cell dp[i] in this table stores the minimum and maximum number of times the shortest path from i to t needs to be recomputed.
