The time it takes to travel the distance could be broken down into smaller segments, with each segment having its own initial and final speed constraints.
Another possibility is defining the state as a tuple (speed_diff, time) where speed_diff is the difference between the current speed and the initial speed, and time is the current second.
State: (speed_diff, time), Transition: (min(final_speed, initial_speed + speed_diff), min(final_speed, initial_speed + speed_diff) + 1) if speed_diff <= max_allowed_change; else 0
Use dynamic programming by initializing a 2D array with size equal to max_allowed_change * time, where dp[i][j] represents the maximum possible length of the path segment for the i-th allowed change in speed and j-th second.
