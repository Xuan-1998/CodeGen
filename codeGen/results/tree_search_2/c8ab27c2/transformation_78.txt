Bottom-up approach with tabulation: You can also solve this problem using dynamic programming by filling up a 2D table where the entry at row i and column j represents the length of the shortest uncommon subsequence in S[i..] and T[j..].
The state expression is dp[i][j] = 1 + (i > 0 and j > 0 and s[i-1] != t[j-1]) or max(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]), and the base case is all zeros.
You can formulate state as: dp[i][j] = 1 + (i > 0 and j > 0 and s[i-1] != t[j-1]) or max(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]), where the base case is all zeros. Then, formulate transition as: for i in range(len(s)): for j in range(len(t)): if s[i] == t[j]: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1]) else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])
Implement memoization using a dictionary where the keys are tuples of indices (i, j) and values are the lengths of shortest uncommon subsequences.
