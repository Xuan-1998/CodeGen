Top-down approach with memoization: You can start by calculating the lengths of common and uncommon subsequences for each pair of characters in S and T. Then, you can use memoization to store these values as you go along, so that you don't have to recalculate them later.
dp[i][j] = 1 if S[:i+1] is not a subsequence of T[:j+1] else min(dp[i-1][j], dp[i][j-1]) + 1
Consider the length of the longest common subsequence (LCS) between S and T. Then, you can calculate the uncommon subsequences as the difference between the lengths of the original strings and the LCS.
Use a 2D array to store the lengths of common subsequences between S[:i+1] and T[:j+1] for each pair of characters in S and T. Initialize dp[0][0] to 0 and fill the rest of the table according to the following rule: dp[i][j] = 1 if S[:i+1] is not a subsequence of T[:j+1] else min(dp[i-1][j], dp[i][j-1]) + 1. Then, return max(i-j for i in range(m+1) and j in range(n+1)) - 1 where m and n are the lengths of S and T respectively.
