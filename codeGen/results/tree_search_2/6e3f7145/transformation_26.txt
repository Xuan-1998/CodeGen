Think about a bottom-up dynamic programming approach where you build up the solution from smaller subproblems by considering each character's impact on the palindrome-ness of its surrounding characters
The base case could be setting all one-character substrings to True (palindromic) and all empty strings to False (not palindromic).
Consider a dynamic programming table with dimensions (len(S), len(S)), where dp[i][j] represents whether the substring S[i...j] is palindromic or not.
Use a 1D array to store the maximum length of palindromic substrings ending at each position in the input string, then iterate through the array to find the longest palindromic substring.
