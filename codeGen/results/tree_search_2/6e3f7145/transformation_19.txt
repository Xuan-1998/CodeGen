Think about a bottom-up dynamic programming approach where you build up the solution from smaller subproblems by considering each character's impact on the palindrome-ness of its surrounding characters
Define the state expression as a 2D array dp where dp[i][j] represents whether the substring S[i...j] is palindromic.
dp[i-1][j-1] == True if S[i-1] == S[j], dp[i-2][j-2] == True, (i, j) within the string's boundaries, and either i = 0 or j = len(S) - 1
You can implement memoization by creating a dictionary to store the results of subproblems as you solve them, so that you don't recompute the same result multiple times.
