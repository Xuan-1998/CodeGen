Think about a bottom-up dynamic programming approach where you build up the solution from smaller subproblems by considering each character's impact on the palindrome-ness of its surrounding characters
Define the state expression as a 1D array p where p[i] represents the length of the longest palindromic substring ending at index i, with base case being p[0] = 0.
The transition relation is: p[i] = max(p[i-1], 2) if S[i] == S[j] and j - i + 1 > p[i-1] for all j in [i, len(S)-1].
Utilize memoization by storing the longest palindromic substring ending at each index in a dictionary for efficient lookups.
