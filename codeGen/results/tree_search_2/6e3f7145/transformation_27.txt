Think about a bottom-up dynamic programming approach where you build up the solution from smaller subproblems by considering each character's impact on the palindrome-ness of its surrounding characters
The base case could be setting all one-character substrings to True (palindromic) and all empty strings to False (not palindromic).
Think about maintaining two pointers, one at the start and one at the end of the string, and expanding them outward as long as the characters match.
Use a bottom-up dynamic programming approach with a 2D table where each cell (i, j) represents whether the substring S[i...j] is palindromic
