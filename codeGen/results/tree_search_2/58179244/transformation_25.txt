Apply a bottom-up dynamic programming approach using tabulation, by iterating through all possible subproblems in order of increasing size.
DP_state = (n, last_color): number of recolors needed for garland up to index n with last color as 'last_color'.
Select DP_state = (n, last_color): number of recolors needed for garland up to index n with last color as 'last_color', considering only the current state.
Use memoization with DP_state = dp[(i, c)]: for (i, c) in itertools.product(range(n+1), set(['R', 'G', 'B'])), where dp[(i, c)] is the minimum number of recolors needed to make a diverse garland up to index i with the last color as c.
