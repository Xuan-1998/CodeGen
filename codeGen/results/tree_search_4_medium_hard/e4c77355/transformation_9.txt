===BEGIN PLAN===
Dynamic Programming:
  Define a recursive relation between subproblems,
  then use memoization to store computed results.

The length of the longest increasing subsequence ending at index i in the array
  Store computed results in a dictionary (dp) and update values based on previously computed values

Use dynamic programming with bottom-up approach:
  Initialize dp with zeros, where dp[i] represents the length of the longest increasing subsequence ending at index i
  For each element arr[i]:
    If arr[i] is greater than all previous elements, then dp[i] = dp[i-1] + 1 (the new element extends the existing increasing subsequence)
    Otherwise, update dp[i] to be the maximum length of the longest increasing subsequence ending at any previous index where the current element is not smaller
  Return max(dp) as the length of the longest increasing subsequence

===END PLAN===
