===BEGIN PLAN===
Identify that each subproblem (sequence length) has overlapping subproblems, so we can use dynamic programming to solve this problem efficiently.
The state expression is (x, y), and the base case is when x ≤ 0 or x > n (program terminates).
State: (x, y) and (last_x, last_y); Transition: ((x + a[x], y + a[x]), (last_x - a[x], last_y + a[x])) where (last_x, last_y) is the previous state
Memoization using a dictionary to store subproblem results; initially set the base case values for x ≤ 0 or x > n
Use a dictionary to store and look up intermediate results; update the transition rules accordingly
Start with the initial state (1, 0), then iterate through the sequence updating the state based on the transitions until termination or reaching the end of the sequence
For each subproblem, calculate the final y value after termination and store it in a list for output
Output the calculated values for each subproblem in order
===END PLAN===
