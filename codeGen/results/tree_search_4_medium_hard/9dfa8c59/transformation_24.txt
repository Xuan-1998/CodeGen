===BEGIN PLAN===
Consider using a hash set to store prime numbers, then iterate over each number below n_max to count its permutations.

Let the state be a boolean value indicating whether the current number is prime, and the base case would be when the number is less than 2.

Maintain an array dp where dp[i] represents whether the number i is prime and has exactly k_perms prime permutations

Use a dynamic programming approach with a boolean array to keep track of whether each number is prime and has exactly k_perms prime permutations. For each number i, check if it's prime by checking if it's not divisible by any number up to its square root. Then, generate all permutations of the digits of i and count how many of them are prime. If this count equals k_perms, mark dp[i] as true.

===END PLAN===
