===BEGIN PLAN===
Identify that each city's shortest distance from capital can be found independently by performing DFS/BFS from the city, which leads to a bottom-up approach with tabulation.
The state expression could be the shortest distance of each city from the capital, i.e., dp[i] = min distance from city i to the capital.
Let dp[i] be the minimum number of edges that need to be reversed such that city i can be reached from the capital. Then dp[i] = min(dp[j] + 1) for all j that have an edge pointing to i.
Design a bottom-up approach using dynamic programming, where the state expression is the shortest distance from the capital to each city.

For the root node (the capital), set dp[root] = 0.
Perform DFS/BFS from the root, updating dp[i] as you visit each node. 
For each unvisited node i, find its parent j such that there's an edge from j to i. Update dp[i] = min(dp[i], dp[j] + 1).
The final answer is min(dp), where dp represents the minimum number of edges to be reversed for a city to be reachable from the capital.

===END PLAN===
