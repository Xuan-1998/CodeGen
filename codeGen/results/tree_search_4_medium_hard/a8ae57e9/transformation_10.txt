===BEGIN PLAN===
Dynamic programming: The problem can be solved using dynamic programming by defining a state that keeps track of the maximum amount of money earned for each group size, and the minimum number of tables required to accommodate all groups with sizes up to the current group size.

The state expression is a 2D array dp where dp[i][j] represents the maximum amount of money earned for all groups with size i and total spending j. The base case is when i = 0 or j = 0, in which case dp[i][j] should be initialized to 0.

The transition relationship is that if we accept the current request, the new state will be the maximum of the previous state and the total spending minus the cost of the current request. If we decline the current request, the new state will be the same as the previous state.

Define a dictionary dp to store the states, where dp[(i, j)] represents the maximum amount of money earned for groups with size up to i and spending up to j.

The dynamic programming algorithm would iterate over all possible group sizes (1 to k) and total spendings (1 to pi), filling in the dp array. The final answer would be the maximum value in the bottom-right corner of the dp array, which represents the maximum amount of money earned for all groups with any size and spending.

Initialize a variable total_earned to keep track of the total amount of money earned from accepted requests.

For each booking request, if its group size is less than or equal to k and the total spending is greater than or equal to dp[k][pi], then accept the request and add pi to total_earned. If the request is declined, do nothing.

The final answer would be total_earned, which represents the maximum amount of money earned from accepted requests.

===END PLAN===
