], [
The state could be represented by (n, m) where n is the remaining size of the alphabet and m is the remaining length of the word. The base case would be when there are no more characters left to place in the word.

dp[(i-1)%n][j] = (i == 0 ? 1 : i % 2 == 0 ? dp[i/2][m-1] * ((n - i/2) % n) + (i/2 > n ? dp[n-i/2-1]%n*m-1)*((n - i/2) % n) : 0), for 0 <= i < n, j >= 0

Use a dictionary to store the memoized results with keys of type (int, int) and values of type int

for t in range(int(input())):
    n = int(input())
    m = int(input())
    dp = {(i, 0): 1 for i in range(n)}
    for i in range(1, min(m+1, n+1)):
        for j in range(min(i, m)+1):
            if i % 2 == 0:
                dp[(i//2)%n, j] = (dp.get((i-1)%n, j-1) or 0) * ((n - i//2) % n)
                if i//2 > n:
                    dp[(n-i//2-1)%n, m-1] = dp.get((n-i//2-1)%n, m-1) or 0
            else:
                dp[i%nm-1] = (dp.get((i-1)%n, j-1) or 0) * ((n - i/2) % n)
    print(sum([dp.get((i,m-1), 0) for i in range(n)] ) % (10**8+7))
