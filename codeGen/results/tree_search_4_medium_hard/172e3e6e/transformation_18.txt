state: dp[i] = whether subsequence ending at index i can be extended to include a[i].
base case: If i > 0, then this state is the same as the previous one because there are no subsequences that can be extended. This means we don't need to consider the first element separately.

transition relationship:
dp[i] = 
    if (i == 1) 
        false  // base case
    else
        1 if (a[i]%i == 0 or (i > 1 and dp[i-1] and a[i]%len(dp[i-1]) == 0))
            else dp[i-1]

represent the problem as recursive function:
function goodSubsequence(a, i)
    if i <= 0
        return 0  // base case: empty subsequence is not good

    if (i > 1 and a[i]%i == 0) 
        return 1  // this element can be included in the subsequence

    if dp[i-1]  // previous subsequence can be extended
        return (dp[i-1] + (a[i]%len(dp[i-1]) == 0)) % (10^9+7)

    return dp[i-1]

// bottom-up approach to fill up the dp table:
dp = [False for _ in range(n+1)]
for i in range(1, n+1)
    dp[i] = goodSubsequence(a, i)

return sum(dp) % (10^9+7)
