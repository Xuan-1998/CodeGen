===BEGIN PLAN===
Consider a bottom-up dynamic programming approach, where you iteratively build up solutions for smaller subarrays and use these results to solve larger subarrays.

Define the state as a tuple (sum, max_val, min_val), where sum is the current sum of the array elements, max_val is the maximum element in the array, and min_val is the minimum element in the array. This allows you to keep track of how the array's properties change as you process each element.

Formulate state transitions based on how these values change when decrementing an element:
- If an element is decremented from the beginning or end of the array, update sum by subtracting the element value, and update max_val and min_val accordingly.
- If all elements are decremented to 0, return "YES".
- Otherwise, if it's not possible to make the array equal to zero (e.g., because an element is too large), return "NO".

Create a memoized dictionary that maps state transitions to their corresponding results.

===END PLAN===
