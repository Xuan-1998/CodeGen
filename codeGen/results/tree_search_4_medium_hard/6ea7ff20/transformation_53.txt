===BEGIN PLAN===
dp[i][j] = 1 if p[2i]+p[2i+1] is less than or equal to p[2j]+p[2j+1], dp[i][j] = 0 otherwise,

Memoization dictionary where the key is a tuple representing the current prefix of p and its length, 
and the value is whether this prefix can be divided into two non-empty arrays with no common elements

For each test case:
    1. Initialize a memoization dictionary with default values as False
    2. Iterate over the permutation from left to right, keeping track of the current prefix's length
    3. For each step, check if the current prefix can be divided into two non-empty arrays with no common elements by comparing p[2i]+p[2i+1] and p[2j]+p[2j+1]
    4. Update the memoization dictionary accordingly
    5. Check if the last element of the permutation is in the same array as its previous element; 
       if so, return "NO", otherwise return "YES"

===END PLAN===
