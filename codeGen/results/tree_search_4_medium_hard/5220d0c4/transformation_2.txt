===BEGIN PLAN===
Identifying overlapping subproblems: For each element in the array, consider the minimum prime divisor of that element. If two elements have the same minimum prime divisor, they can be combined into a single subproblem.

The state expression could be defined as a tuple (i, j) representing the range [0, i] in the array and the set of bad prime numbers up to j.

The state is a pair (i, k) where i represents the index in the array and k is the maximum bad prime number considered so far.

Implement a recursive function with memoization using a dictionary:

function beautyDP(i, k):
    if (i, k) in memo:
        return memo[(i, k)]

    if i == 0:
        return 0

    minPrimeDivisor = getMinPrimeDivisor(arr[i])
    isBadPrime = isPrime(minPrimeDivisor)
    if isBadPrime and k > minPrimeDivisor:
        k = minPrimeDivisor

    beauty = beautyDP(i - 1, k)
    if not isBadPrime or k == minPrimeDivisor:
        beauty += arr[i]
    else:
        beauty -= arr[i]

    memo[(i, k)] = beauty
    return beauty

function getMinPrimeDivisor(n):
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return i
    return n

function isPrime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

===END PLAN===
