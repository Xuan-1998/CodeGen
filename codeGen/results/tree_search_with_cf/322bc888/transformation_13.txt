
1. Precompute all possible "beautiful" strings of length up to 3 using the first three lowercase Latin alphabets. There are 6 such strings: "abc", "acb", "bac", "bca", "cab", "cba".
2. For each of these "beautiful" strings, compute the cost to transform any substring of the input string into this "beautiful" string.
3. Use dynamic programming to precompute the cost of transforming substrings of the input string into each of the 6 "beautiful" strings. Let dp[k][i] be the cost to transform the prefix of length i of the input string into the k-th "beautiful" string.
4. For each query, use the precomputed dp array to efficiently compute the minimum cost to transform the queried substring into one of the "beautiful" strings.
5. For each query, output the minimum cost among the 6 possible transformations.

Detailed Steps:
1. Generate the 6 possible "beautiful" strings: ["abc", "acb", "bac", "bca", "cab", "cba"].
2. Initialize a dp array of size 6 x (n+1), where dp[k][i] represents the cost to transform the prefix of length i of the input string into the k-th "beautiful" string.
3. For each i from 1 to n, compute dp[k][i] for each of the 6 "beautiful" strings:
   - dp[k][i] = dp[k][i-1] + (s[i-1] != beautiful[k][(i-1) % 3])
   - This computes the cost incrementally by comparing the current character of the input string with the corresponding character in the "beautiful" string.
4. For each query (l_i, r_i), compute the minimum cost to transform the substring s[l_i-1:r_i] into one of the 6 "beautiful" strings:
   - For each k from 0 to 5, the cost is dp[k][r_i] - dp[k][l_i-1]
   - Output the minimum of these 6 costs for each query.

