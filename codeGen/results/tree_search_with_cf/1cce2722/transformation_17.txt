
1. Count Frequencies: Create an array `count` where `count[x]` represents the frequency of the integer `x` in the sequence. This array will be of size 105 (since 1 ≤ ai ≤ 105).

2. Initialize DP Array: Create a dp array `dp` where `dp[x]` represents the maximum points that can be obtained considering all integers from 1 to x. The size of this array will also be 105.

3. Base Cases: Set the base cases for the dp array:
   - dp[0] = 0: If there are no numbers, the maximum points are 0.
   - dp[1] = count[1] * 1: If we only consider the number 1, the maximum points are the frequency of 1 multiplied by 1.

4. Transition Relation: For each integer x from 2 to 105, update the dp array using the following relation:
   - dp[x] = max(dp[x-1], dp[x-2] + count[x] * x)
   This relation ensures that we either skip the current number x (and take the result from dp[x-1]) or take the current number x (and add its points to the result from dp[x-2]).

5. Result: The final answer will be dp[105], which will store the maximum points that can be obtained considering all integers from 1 to 105.

6. Edge Cases: Consider edge cases such as when n = 1 (only one number in the sequence) and when all numbers in the sequence are the same.


