
1. Frequency Count: Create an array `count` of size 105 (since the maximum value of ai is 105) to store the frequency of each integer in the sequence. Iterate through the sequence and populate the `count` array.

2. Bottom-Up Strategy with Tabulation: This approach builds up the solution iteratively from the base cases using a table to store results of subproblems. The time complexity is O(n) and space complexity is O(105) due to the table used for storing results.

3. State Expression: Let `dp[x]` be the maximum points that can be obtained considering all integers from 1 to x. The transition relation will be `dp[x] = max(dp[x-1], dp[x-2] + count[x] * x)`, where `count[x]` is the frequency of the integer x in the sequence.

4. Base Cases: `dp[0] = 0` and `dp[1] = count[1] * 1`. These base cases are essential for the transition relation to build upon.

5. Iteration: Iterate from 2 to 105 (the maximum possible value of ai) and apply the transition relation to fill up the `dp` array.

6. Result: The value `dp[105]` will contain the maximum points that can be obtained through the operations.

7. Edge Cases: Ensure to handle edge cases where the sequence length n is 1 or where all elements in the sequence are the same.

