{"urls": "https://practice.geeksforgeeks.org/problems/the-painters-partition-problem1535/1", "editorial": "// CPP program for painter's partition problem\n#include <iostream>\n#include <climits>\nusing namespace std;\n\n// return the maximum element from the array\nint getMax(int arr[], int n)\n{\n    int max = INT_MIN;\n    for (int i = 0; i < n; i++)\n        if (arr[i] > max)\n            max = arr[i];\n    return max;\n}\n\n// return the sum of the elements in the array\nint getSum(int arr[], int n)\n{\n    int total = 0;\n    for (int i = 0; i < n; i++)\n        total += arr[i];\n    return total;\n}\n\n// find minimum required painters for given maxlen\n// which is the maximum length a painter can paint\nint numberOfPainters(int arr[], int n, int maxLen)\n{\n    int total = 0, numPainters = 1;\n\n    for (int i = 0; i < n; i++) {\n        total += arr[i];\n\n        if (total > maxLen) {\n\n            // for next count\n            total = arr[i];\n            numPainters++;\n        }\n    }\n\n    return numPainters;\n}\n\nint partition(int arr[], int n, int k)\n{\n    int lo = getMax(arr, n);\n    int hi = getSum(arr, n);\n\n    while (lo < hi) {\n        int mid = lo + (hi - lo) / 2;\n        int requiredPainters = numberOfPainters(arr, n, mid);\n\n        // find better optimum in lower half\n        // here mid is included because we\n        // may not get anything better\n        if (requiredPainters <= k)\n            hi = mid;\n\n        // find better optimum in upper half\n        // here mid is excluded because it gives\n        // required Painters > k, which is invalid\n        else\n            lo = mid + 1;\n    }\n\n    // required\n    return lo;\n}\n\n// driver function\nint main()\n{\n    int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int k = 3;\n    cout << partition(arr, n, k) << endl;\n    return 0;\n}"}
{"urls": "https://practice.geeksforgeeks.org/problems/find-all-distinct-subset-or-subsequence-sums4424/1", "editorial": "class Solution {\n    public:\n        vector<int> DistinctSum(vector<int>nums){\n            int n = nums.size();\n            int sum = 0;\n            for(auto i: nums)sum += i;\n            vector<vector<bool>>dp(n+1, vector<bool>(sum+1, false));\n            for(int i = 0; i <= n; i++)dp[i][0] = true;\n            for(int i = 1; i <= n; i++){\n                dp[i][nums[i-1]] = true;\n                for(int j = 1; j <= sum; j++){\n                    if(dp[i-1][j]){\n                        dp[i][j] = true;\n                        dp[i][j + nums[i-1]] = true;\n                    }\n                }\n            }\n            vector<int>ans;\n            for(int j = 0; j <= sum; j++){\n                if(dp[n][j])ans.push_back(j);\n            }\n            return ans;\n        }\n    };"}
{"urls": "https://practice.geeksforgeeks.org/problems/899540d741547e2d75d1c5c03a4161ab53affd13/1", "editorial": "//Back-end complete function Template for C++\n\nclass Solution\n{\n    public:\n        // Function to check if current minimum height is valid or not.\n        bool isvalid(vector <int> &a, int n, int k, int w, long long int mid)\n        {\n            // Array to store the prefix sum of the previous heights.\n            long long int ps[n];\n            fill(ps, ps+n, 0ll);\n            long long int ans = 0;\n\n            // Iterating over each height.\n            for(long long int i = 0; i < n; i++)\n            {\n                // Calculating the prefix sum and checking if the current height is less than the current minimum height.\n                if(i - 1 >= 0)\n                    ps[i] += ps[i-1];\n                if(a[i] + ps[i] < mid)\n                {\n                    // Updating the prefix sum and the total number of adjustments required.\n                    long long int e = mid - a[i] - ps[i];\n                    ans += e;\n                    ps[i] += e;\n\n                    // Reducing the height adjustments for the next window of width w.\n                    if(i + w < n)\n                        ps[i+w] -= e;\n                }\n            }\n            return (ans <= k); // Checking if the total adjustments required is less than or equal to k.\n        }\n\n        // Function to maximize the minimum height.\n        long long int maximizeMinHeight(int n, int k, int w, vector <int> &a)\n        {\n            int ans = 0;\n            long long int l = 0, h = 1e14;\n\n            // Binary search to find the maximum valid minimum height.\n            while(l <= h)\n            {\n                long long int mid = (l + h) / 2;\n\n                // Checking if the current height is valid.\n                if(isvalid(a, n, k, w, mid))\n                {\n                    l = mid + 1; // Updating the lower bound.\n                    ans = mid; // Updating the maximum valid minimum height.\n                }\n                else\n                {\n                    h = mid - 1; // Updating the upper bound.\n                }\n            }\n            return ans; // Returning the maximum valid minimum height.\n        }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/a4f19ea532cee502aabec77c07e0d0a45b76ecf9/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/longest-substring-whose-character-rearranged-can-form-a-palindrome/1", "editorial": "// C++ program for the above approach \n#include<bits/stdc++.h>\nusing namespace std;\n    \n// Function to get the length of longest \n// substring whose characters can be \n// arranged to form a palindromic string \nint longestSubstring(string s, int n) \n{ \n    \n    // To keep track of the last \n    // index of each xor \n    map<int, int> index;\n    \n    // Initialize answer with 0 \n    int answer = 0; \n\n    int mask = 0; \n    index[mask] = -1; \n\n    // Now iterate through each character \n    // of the string \n    for(int i = 0; i < n; i++) \n    { \n        \n        // Convert the character from \n        // [a, z] to [0, 25] \n        int temp = (int)s[i] - 97; \n\n        // Turn the temp-th bit on if \n        // character occurs odd number \n        // of times and turn off the temp-th \n        // bit off if the character occurs \n        // ever number of times \n        mask ^= (1 << temp); \n\n        // If a mask is present in the index \n        // Therefore a palindrome is \n        // found from index[mask] to i \n        if (index[mask]) \n        { \n            answer = max(answer, \n                         i - index[mask]); \n        } \n\n        // If x is not found then add its \n        // position in the index dict. \n        else\n            index[mask] = i; \n\n        // Check for the palindrome of \n        // odd length \n        for(int j = 0; j < 26; j++) \n        { \n            \n            // We cancel the occurrence \n            // of a character if it occurs \n            // odd number times \n            int mask2 = mask ^ (1 << j); \n            if (index[mask2]) \n            { \n                answer =max(answer, \n                            i - index[mask2]); \n            } \n        } \n    } \n    return answer; \n} \n        \n// Driver code \nint main () \n{ \n    \n    // Given String \n    string s = \"adbabd\"; \n    \n    // Length of given string \n    int n = s.size(); \n    \n    // Function call \n    cout << (longestSubstring(s, n)); \n}\n\n// This code is contributed by Stream_Cipher\n "}
{"urls": "https://practice.geeksforgeeks.org/problems/shortest-uncommon-subsequence5746/1", "editorial": "// A dynamic programming based C++ program\n// to find shortest uncommon subsequence.\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 1005\n\n// Returns length of shortest common subsequence\nint shortestSeq(char *S, char *T)\n{\n    int m = strlen(S), n = strlen(T);\n\n    // declaring 2D array of m + 1 rows and\n    // n + 1 columns dynamically\n    int dp[m+1][n+1];\n\n    // T string is empty\n    for (int i = 0; i <= m; i++)\n        dp[i][0] = 1;\n\n    // S string is empty\n    for (int i = 0; i <= n; i++)\n        dp[0][i] = MAX;\n\n    for (int i = 1; i <= m; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            char ch = S[i-1];\n            int k;\n            for (k = j-1; k >= 0; k--)\n                if (T[k] == ch)\n                    break;\n\n            // char not present in T\n            if (k == -1)\n                dp[i][j] = 1;\n            else\n               dp[i][j] = min(dp[i-1][j], dp[i-1][k] + 1);\n        }\n    }\n\n    int ans = dp[m][n];\n    if (ans >= MAX)\n        ans = -1;\n\n    return ans;\n}\n\n// Driver program to test the above function\nint main()\n{\n    char S[] = \"babab\";\n    char T[] = \"babba\";\n    int m = strlen(S), n = strlen(T);\n    cout << \"Length of shortest subsequence is : \"\n         << shortestSeq(S, T) << endl;\n}"}
{"urls": "https://practice.geeksforgeeks.org/problems/number-of-paths-in-a-matrix-with-k-coins2728/1", "editoria l": "class Solution {\n    public:\n        // Dynamic programming array to store results\n        long long dp[101][101][101];\n        // Array to store the values of the grid\n        int a[101][101];\n        \n        // Recursive function to find the number of paths\n        long long go(int n,int m,int k)\n        {\n            // Base cases\n            if(k<0)\n                return 0;\n            if(m<0||n<0)\n                return 0;\n            if(n==0&&m==0)\n                return dp[n][m][k]=(k==a[n][m]);\n                \n            // If result already calculated, return it\n            if(dp[n][m][k]!=-1)\n                return dp[n][m][k];\n                \n            // Calculate number of paths by moving left and up\n            long long left = go(n,m-1,k-a[n][m]);\n            long long up = go(n-1,m,k-a[n][m]);\n            \n            // Store the result in dp array\n            return dp[n][m][k] = left + up;\n        }\n        \n        // Function to find the number of paths\n        long long numberOfPath(int n, int k, vector<vector<int>> &arr){\n            // Copy the grid values into array a\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    a[i][j] = arr[i][j];\n                }\n            }\n            \n            // Initialize dp array with -1\n            for(int i=0;i<n;i++)\n                for(int j=0;j<n;j++)\n                    for(int l=0;l<=k;l++)\n                        dp[i][j][l]=-1;\n            \n            // Call the recursive function to find the number of paths\n            go(n-1,n-1,k);\n            \n            // Return the result\n            return dp[n-1][n-1][k];\n        }\n    };"}
{"urls": "https://practice.geeksforgeeks.org/problems/print-first-n-fibonacci-numbers1002/1", "editorial": "//Back-end complete function template for C++\n\nclass Solution\n{\n    public:\n    //Function to return list containing first n fibonacci numbers.\n    vector<long long> printFibb(int n) \n    {\n        //creating a list to store the numbers.\n        vector<long long> ans;\n        \n        //storing base values for a and b.\n        long long int a=1,b=1;\n        \n        //pushing 1 once in the list if n>=1 and again if n>=2.\n        if(n>=1)\n            ans.push_back(1);\n        if(n>=2) \n            ans.push_back(1);\n            \n        \n        for(int i = 2 ; i < n ; ++ i ) \n        {\n            //pushing sum of a and b in the list.\n            ans.push_back(a+b);\n            long long int c=a+b;\n            \n            //updating a as b and b as c(sum of a and b).\n            a=b;\n            b=c;\n        }\n        \n        //returning the list.\n        return ans;\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/ways-to-sum-to-n5759/1", "editorial": "#define mod 1000000007\nclass Solution\n{\n  public:\n    // function to count the total  \n    // number of ways to sum up to 'N' \n    int countWays(int arr[], int m, int N) \n    { \n        int count[N + 1]; \n        memset(count, 0, sizeof(count)); \n          \n        // base case \n        count[0] = 1; \n          \n        // count ways for all values up  \n        // to 'N' and store the result \n        for (int i = 1; i <= N; i++) \n            for (int j = 0; j < m; j++) \n      \n                // if i >= arr[j] then \n                // accumulate count for value 'i' as \n                // ways to form value 'i-arr[j]' \n                if (i >= arr[j]) \n                    count[i] = (count[i]%mod + count[i - arr[j]]%mod )%mod; \n          \n        // required number of ways  \n        return count[N];  \n          \n    } \n    \n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/maximize-dot-product2649/1", "editorial": "class Solution{\n\t\t\n\n\tpublic:\n\tint maxDotProduct(int n, int m, int a[], int b[]) \n\t{ \n\t\t// Create 2D Matrix that stores dot product \n\t    // dp[i+1][j+1] stores product considering b[0..i] \n\t    // and a[0...j]. Note that since all m > n, we fill \n\t    // values in upper diagonal of dp[][] \n\t    int dp[m+1][n+1]; \n\t    memset(dp, 0, sizeof(dp)); \n\t  \n\t    // Traverse through all elements of B[] \n\t    for (int i=1; i<=m; i++) \n\t  \n\t        // Consider all values of a[] with indexes greater \n\t        // than or equal to i and compute dp[i][j] \n\t        for (int j=i; j<=n; j++) \n\t  \n\t            // Two cases arise \n\t            // 1) Include a[j] \n\t            // 2) Exclude a[j] (insert 0 in b[])  \n\t            dp[i][j] = max((dp[i-1][j-1] + (a[j-1]*b[i-1])) , \n\t                            dp[i][j-1]); \n\t  \n\t    // return Maximum Dot Product \n\t    return dp[m][n] ; \n\t} \n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/subset-with-sum-divisible-by-m2546/1", "editorial": "class Solution{\n\tpublic:\n\n\t\tint DivisibleByM(vector<int>nums, int m){\n\t\t\tint n = nums.size();\n\t\t    if (n > m)\n\t\t        return 1;\n\t\t \n\t\t    // This array will keep track of all\n\t\t    // the possible sum (after modulo m)\n\t\t    // which can be made using subsets of arr[]\n\t\t    // initialising boolean array with all false\n\t\t    bool DP[m];\n\t\t    memset(DP, false, m);\n\t\t \n\t\t    // we'll loop through all the elements of arr[]\n\t\t    for (int i=0; i<n; i++)\n\t\t    {\n\t\t        // anytime we encounter a sum divisible\n\t\t        // by m, we are done\n\t\t        if (DP[0])\n\t\t            return true;\n\t\t \n\t\t        // To store all the new encountered sum (after\n\t\t        // modulo). It is used to make sure that arr[i]\n\t\t        // is added only to those entries for which DP[j] \n\t\t        // was true before current iteration.  \n\t\t        bool temp[m];\n\t\t        memset(temp,false,m);\n\t\t \n\t\t        // For each element of arr[], we loop through\n\t\t        // all elements of DP table from 1 to m and\n\t\t        // we add current element i. e., arr[i] to\n\t\t        // all those elements which are true in DP\n\t\t        // table\n\t\t        for (int j=0; j<m; j++)\n\t\t        {\n\t\t            // if an element is true in DP table\n\t\t            if (DP[j] == true)\n\t\t            {\n\t\t                if (DP[(j+nums[i]) % m] == false)\n\t\t \n\t\t                    // We update it in temp and update\n\t\t                    // to DP once loop of j is over\n\t\t                    temp[(j+nums[i]) % m] = true;\n\t\t            }\n\t\t        }\n\t\t \n\t\t        // Updating all the elements of temp\n\t\t        // to DP table since iteration over\n\t\t        // j is over\n\t\t        for (int j=0; j<m; j++)\n\t\t            if (temp[j])\n\t\t                DP[j] = true;\n\t\t \n\t\t \n\t\t        // Also since arr[i] is a single element\n\t\t        // subset, arr[i]%m is one of the possible\n\t\t        // sum\n\t\t        DP[nums[i]%m] = true;\n\t\t    }\n\t\t \n\t\t    return DP[0];\n\t\t}\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/count-of-subarrays5922/1", "editorial": "//Back-end complete function template for C++\n#define MAX 256\n\nclass Solution{\npublic:\n\t// Return number of subarrays whose maximum\n\t// element is less than or equal to K.\n\tll countSubarray(int arr[], int n, int k) {\n\t    // To store count of subarrays with all\n\t    // elements less than or equal to k.\n\t    ll s = 0;\n\n\t    // Traversing the array.\n\t    int i = 0;\n\t    while (i < n) {\n\t        // If element is greater than k, ignore.\n\t        if (arr[i] > k) {\n\t            i++;\n\t            continue;\n\t        }\n\n\t        // Counting the subarray length whose\n\t        // each element is less than equal to k.\n\t        ll count = 0;\n\t        while (i < n && arr[i] <= k) {\n\t            i++;\n\t            count++;\n\t        }\n\n\t        // Suming number of subarray whose\n\t        // maximum element is less than equal to k.\n\t        s += ((count * (count + 1)) / 2);\n\t    }\n\n\t    return (((ll)n * (ll)(n + 1) / 2) - s);\n\t}\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/longest-palindrome-in-a-string3411/1", "editorial": "class Solution {\n  public:\n    string longestPalin (string S)\n    {\n        int fi = 0, fj = 0, j, k, n = S.length ();\n    \n        for (int i = 0; i < n; ++i)\n        {\n            // odd length palindrome with current index as center\n            j = i - 1;\n            k = i + 1;\n            while (j >= 0 and k < n)\n            {\n                if (S[j] != S[k])\n                    break;\n                j--;\n                k++;\n            }\n            if (k - j - 1 > fj - fi + 1)\n            {\n                fi = j + 1;\n                fj = k - 1;\n            }\n    \n            // even length palindrome if possible\n            if (i < n - 1 and S[i] == S[i + 1])\n            {\n                j = i - 1;\n                k = i + 2;\n                while (j >= 0 and k < n)\n                {\n                    if (S[j] != S[k])\n                        break;\n                    j--;\n                    k++;\n                }\n                if (k - j - 1 > fj - fi + 1)\n                {\n                    fi = j + 1;\n                    fj = k - 1;\n                }\n            }\n        }\n    \n        return S.substr (fi, fj - fi + 1);\n    }\n    // Contributed By: Pranay Bansal\n\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/longest-alternating-subsequence5951/1", "editorial": "class Solution {\n\tpublic:\n\t\t// Function to find the maximum length of alternating subsequence\n\t\tint AlternatingaMaxLength(vector<int>& nums) {\n\t\t\t// If the size of the nums array is less than 2, return the size itself\n\t\t\tif (nums.size() < 2)\n\t\t\t\treturn nums.size();\n\t\t\tint up = 1, down = 1;\n\t\t\t// Iterate through the nums array starting from the second element\n\t\t\tfor (int i = 1; i < nums.size(); i++) {\n\t\t\t\t// If the current number is greater than the previous number, increase the \"up\" count\n\t\t\t\tif (nums[i] > nums[i-1])\n\t\t\t\t\tup = down + 1;\n\t\t\t\t// If the current number is less than the previous number, increase the \"down\" count\n\t\t\t\telse if (nums[i] < nums[i-1])\n\t\t\t\t\tdown  = up + 1;\n\t\t\t}\n\t\t\t// Return the maximum value between \"up\" and \"down\"\n\t\t\treturn max(up, down);\n\t\t}\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/longest-subsequence-such-that-difference-between-adjacents-is-one4724/1", "editorial": "// Back-end complete function Template for C++\n\nclass Solution{\npublic:\n    int longestSubsequence(int N, int A[])\n    {\n        // Initializing the dp array\n        int dp[N];\n        for(int i = 0;i < N;i++)\n            dp[i] = 1;\n        \n        // Calculating longest subsequence with adjacent elements having \n        // difference of 1\n        for(int i = 1;i < N;i++){\n            for(int j = 0;j < i;j++){\n                if(abs(A[i] - A[j]) == 1)\n                    dp[i] = max(dp[i],dp[j]+1);\n            }\n        }\n        \n        // calculating the answer\n        int ans = 1;\n        for(int i = 0;i < N;i++)\n            ans = max(ans, dp[i]);\n        \n        return ans;\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/perfect-sum-problem5633/1", "editorial": "// Back-end complete function template in C++\nclass Solution{\n\n    int mod = (int)(1e9 + 7); // Initialize mod value for calculations\n    vector<vector<int>> dp; // 2D vector to store dynamic programming values\n    int N; // Size of the array\n\n    int fun(int pos, int sum, int arr[]) {\n        if (pos >= N)\n            return sum == 0; // Check if sum is zero when array position reaches end\n\n        int &ans = dp[pos][sum]; // Reference to store calculated value in dp vector\n        if (ans != -1)\n            return ans; // Return the already calculated value from dp vector\n\n        ans = 0; // Initialize answer with zero\n\n        ans += fun(pos + 1, sum, arr); // Recursively call function for next position with sum unchanged\n        ans %= mod; // Take modulo of the answer to avoid overflow\n        if (arr[pos] <= sum)\n            ans += fun(pos + 1, sum - arr[pos], arr), ans %= mod; // Recursively call function for next position with reduced sum\n\n        return ans; // Return the calculated answer\n           \n    }\n\n    public:\n    int perfectSum(int arr[], int n, int sum)\n    {\n        dp.assign(n + 1, vector<int> (sum + 2, -1)); // Initialize dp vector with -1\n        N = n; // Assign n to N variable\n        \n        return fun(0, sum, arr); // Call recursive function with initial parameters\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/lcs-of-0-k-repeated-string5642/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/count-the-paths4332/1", "editorial": "class Solution {\npublic:\n\tint count_dfs(vector<vector<int>>graph, int u, int d, vector<bool>&vis){\n\t\tif(u == d)\n\t\t\treturn 1;\n\t\tvis[u] = true;\n\t\tint ans = 0;\n\t\tfor(auto v: graph[u]){\n\t\t\tif(!vis[v])\n\t\t\t\tans += count_dfs(graph, v, d, vis);\n\t\t}\n\t\tvis[u] = false;\n\t\treturn ans;\n\t}\n\tint possible_paths(vector<vector<int>>edges, int n, int s, int d){\n\t\tvector<vector<int>>graph(n);\n\t\tfor(auto i: edges)\n\t\t\tgraph[i[0]].push_back(i[1]);\n\t\tvector<bool>vis(n, false);\n\t\treturn count_dfs(graph, s, d, vis);\n\t}\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/mobile-numeric-keypad5456/1", "editorial": "class Solution{\n\n\tprivate:\n\tlong long getCountUtil(char keypad[][3], int n) \n\t{ \n\t    if(keypad == NULL || n <= 0) \n\t        return 0; \n\t    if(n == 1) \n\t        return 10; \n\t  \n\t    // left, up, right, down move from current location \n\t    int row[] = {0, 0, -1, 0, 1}; \n\t    int col[] = {0, -1, 0, 1, 0}; \n\t  \n\t    // taking n+1 for simplicity - count[i][j] will store \n\t    // number count starting with digit i and length j \n\t    long long count[10][n+1]; \n\t    int i=0, j=0, k=0, move=0, ro=0, co=0, num = 0; \n\t    long long nextNum=0, totalCount = 0; \n\t  \n\t    // count numbers starting with digit i and of lengths 0 and 1 \n\t    for (i=0; i<=9; i++) \n\t    { \n\t        count[i][0] = 0; \n\t        count[i][1] = 1; \n\t    } \n\t  \n\t    // Bottom up - Get number count of length 2, 3, 4, ... , n \n\t    for (k=2; k<=n; k++) \n\t    { \n\t        for (i=0; i<4; i++)  // Loop on keypad row \n\t        { \n\t            for (j=0; j<3; j++)   // Loop on keypad column \n\t            { \n\t                // Process for 0 to 9 digits \n\t                if (keypad[i][j] != '*' && keypad[i][j] != '#') \n\t                { \n\t                    // Here we are counting the numbers starting with \n\t                    // digit keypad[i][j] and of length k keypad[i][j] \n\t                    // will become 1st digit, and we need to look for \n\t                    // (k-1) more digits \n\t                    num = keypad[i][j] - '0'; \n\t                    count[num][k] = 0; \n\t  \n\t                    // move left, up, right, down from current location \n\t                    // and if new location is valid, then get number \n\t                    // count of length (k-1) from that new digit and \n\t                    // add in count we found so far \n\t                    for (move=0; move<5; move++) \n\t                    { \n\t                        ro = i + row[move]; \n\t                        co = j + col[move]; \n\t                        if (ro >= 0 && ro <= 3 && co >=0 && co <= 2 && \n\t                           keypad[ro][co] != '*' && keypad[ro][co] != '#') \n\t                        { \n\t                            nextNum = keypad[ro][co] - '0'; \n\t                            count[num][k] += count[nextNum][k-1]; \n\t                        } \n\t                    } \n\t                } \n\t            } \n\t        } \n\t    } \n\t  \n\t    // Get count of all possible numbers of length \"n\" starting \n\t    // with digit 0, 1, 2, ..., 9 \n\t    totalCount = 0; \n\t    for (i=0; i<=9; i++) \n\t        totalCount += count[i][n]; \n\t    return totalCount; \n\t} \n\n\tpublic:\n\tlong long getCount(int N)\n\t{\n\t\tchar keypad[4][3] = {{'1','2','3'}, \n                        {'4','5','6'}, \n                        {'7','8','9'}, \n                        {'*','0','#'}}; \n\n        return getCountUtil(keypad, N);\n\t}\n\n\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/minimum-steps-to-minimize-n-as-per-given-condition0618/1", "editorial": "//Back-end complete function template in C++\n\nclass Solution {\n\n  public:\n  //Function to find minimum number of steps required to reach N.\n  int minSteps(int N) {\n\n    //creating a table to store minimum steps required to reach each number.\n    int table[N + 1];\n\n    //initializing the table with default values.\n    for (int i = 0; i <= N; i++)\n      table[i] = N - i;\n\n    //iterating backwards from N-1 to 1.\n    for (int i = N - 1; i >= 1; i--) {\n\n      //taking minimum of current value and next value + 1.\n      table[i] = min(table[i], table[i + 1] + 1);\n\n      //taking minimum of current value and double value + 1 if it is less than or equal to N.\n      if (i * 2 <= N)\n        table[i] = min(table[i], table[i * 2] + 1);\n\n      //taking minimum of current value and triple value + 1 if it is less than or equal to N.\n      if (i * 3 <= N)\n        table[i] = min(table[i], table[i * 3] + 1);\n    }\n\n    //returning the minimum steps required to reach 1.\n    return table[1];\n  }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/number-of-subsequences-in-a-string-divisible-by-n5947/1", "editorial": "class Solution{\n\n\tint mod = (int)(1e9 + 7);\n\n\tpublic:\n\tint countDivisibleSubseq(string str, int N)\n\t{\n\t    int len = str.length();\n\t \n\t    // division by n can leave only n remainder\n\t    // [0..n-1]. dp[i][j] indicates number of\n\t    // subsequences in string [0..i] which leaves\n\t    // remainder j after division by n.\n\t    long long dp[len+1][N+1];\n\t    memset(dp, 0, sizeof(dp));\n\t \n\t    // Filling value for first digit in str\n\t    dp[0][(str[0]-'0')%N]++;\n\t \n\t    for (int i=1; i<len; i++)\n\t    {\n\t        // start a new subsequence with index i\n\t        dp[i][(str[i]-'0')%N]++;\n\t \n\t        for (int j=0; j<N; j++)\n\t        {\n\t            // exclude i'th character from all the\n\t            // current subsequences of string [0...i-1]\n\t            dp[i][j] =(dp[i][j]%mod+ dp[i-1][j]%mod)%mod;\n\t \n\t            // include i'th character in all the current\n\t            // subsequences of string [0...i-1]\n\t            dp[i][(j*10 + (str[i]-'0'))%N] =(dp[i][(j*10 + (str[i]-'0'))%N]%mod+ dp[i-1][j]%mod)%mod;\n\t        }\n\t    }\n\t \n\t    return (int)dp[len-1][0]%mod;\n\t}\n\t  \n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/palindromic-patitioning4845/1", "editorial": "// Back-end complete function Template for C++\n\nclass Solution{\npublic:\n    int palindromicPartition(string str){\n        int n = str.size();\n        \n         /* Create two arrays to build the solution in bottom up manner\n           C[i] = Minimum number of cuts needed for palindrome partitioning\n                     of substring str[0..i]\n           P[i][j] = true if substring str[i..j] is palindrome, else false\n           Note that C[i] is 0 if P[0][i] is true */\n        int C[n];\n        bool P[n][n];\n        \n        int i, j, k, L;\n        for(i = 0;i < n;i++)\n            P[i][i] = true;\n        \n        for(L = 2; L <= n;L++){\n            for(i = 0;i < n-L+1;i++){\n                j = i+L-1;   // set ending index\n                \n                // If L is 2, then we just need to compare two characters. Else\n                // need to check two corner characters and value of P[i+1][j-1]\n                if(L == 2)\n                    P[i][j] = (str[i] == str[j]);\n                else\n                    P[i][j] = ((str[i] == str[j]) & P[i+1][j-1]);\n            } \n        }\n        \n        for(i = 0;i < n;i++){\n            if(P[0][i])\n                C[i] = 0;\n            else{\n                C[i] = INT_MAX;\n                for(j = 0;j < i;j++){\n                    if(P[j+1][i] == true & C[j]+1 < C[i])\n                        C[i] = C[j]+1;\n                }\n            }\n        }\n        return C[n-1];\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/find-all-possible-palindromic-partitions-of-a-string/1", "editorial": "//Back-end complete function Template for C++\n\nclass Solution {\n  public:\n    // A utility function to check if str is palindroem \n    bool isPalindrome(string str, int low, int high) \n    { \n        while (low < high) \n        { \n            if (str[low] != str[high]) \n                return false; \n            low++; \n            high--; \n        } \n        return true; \n    }\n\n    // Recursive function to find all palindromic partitions of str[start..n-1] \n    // allPart --> A vector of vector of strings. Every vector inside it stores \n    //             a partition \n    // currPart --> A vector of strings to store current partition  \n    void allPalPartUtil(vector<vector<string> >&allPart, vector<string> &currPart,  \n                       int start, int n, string str) \n    { \n        // If 'start' has reached len \n        if (start >= n) \n        { \n            allPart.push_back(currPart); \n            return; \n        } \n      \n        // Pick all possible ending points for substrings \n        for (int i=start; i<n; i++) \n        { \n            // If substring str[start..i] is palindrome \n            if (isPalindrome(str, start, i)) \n            { \n                // Add the substring to result \n                currPart.push_back(str.substr(start, i-start+1)); \n      \n                // Recur for remaining remaining substring \n                allPalPartUtil(allPart, currPart, i+1, n, str); \n                  \n                // Remove substring str[start..i] from current  \n                // partition \n                currPart.pop_back(); \n            } \n        } \n    }\n\n    vector<vector<string>> allPalindromicPerms(string S) {\n        int n = S.length(); \n  \n        // To Store all palindromic partitions \n        vector<vector<string> > allPart; \n      \n        // To store current palindromic partition \n        vector<string> currPart;  \n      \n        // Call recursive function to generate all partiions \n        // and store in allPart \n        allPalPartUtil(allPart, currPart, 0, n, S); \n\n        return allPart;\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/express-as-sum-of-power-of-natural-numbers5647/1", "editorial": "//Back-end complete function Template for C++\n\nclass Solution\n{\npublic:\n    //Function to find the number of ways to form the sum.\n    int numOfWays(int n, int x)\n    {\n        //Creating a vector dp of size n+1 to store the number of ways to form each sum.\n        vector<int> dp(n + 1, 0);\n        \n        //Initializing the base case where the sum is 0, which is 1 way.\n        dp[0] = 1;\n        \n        //Setting the value of MOD as 10^9 + 7 for taking modulo while performing operations.\n        int MOD = 1e9 + 7;\n        \n        //Iterating from 1 to n to calculate the number of ways for each sum.\n        for (int i = 1; i <= n; i++)\n        {\n            //Iterating from n to i as we need to go in reverse order to avoid repeated calculations.\n            for (int j = n; j >= i; j--)\n            {\n                //Calculating i raised to the power of x and storing it in y.\n                unsigned long int y = pow(i, x);\n\n                //Checking if the current sum j is greater than or equal to y.\n                if (j >= y)\n                {\n                    //Updating the number of ways to form the sum j by adding the number of ways to form the sum (j-y).\n                    dp[j] = (dp[j] + dp[j - y]) % MOD;\n                }\n            }\n        }\n        \n        //Returning the number of ways to form the sum n.\n        return dp[n];\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/minimum-cost-to-fill-given-weight-in-a-bag1956/1", "editorial": "#include <bits/stdc++.h>\nusing namespace std;\n//Position this line where user code will be pasted.\n\nclass Solution{\n\t\t\n\n\tpublic:\n\tint minimumCost(int cost[], int N, int W) \n\t{ \n\n\t\tint INF = 999999999;\n\n\t    // val[] and wt[] arrays \n\t    // val[] array to store cost of 'i' kg packet of orange \n\t    // wt[] array weight of packet of orange \n\t    vector<int> val, wt; \n\t  \n\t    // traverse the original cost[] array and skip \n\t    // unavailable packets and make val[] and wt[] \n\t    // array. size variable tells the available number \n\t    // of distinct weighted packets \n\t    int size = 0; \n\t    for (int i=0; i<N; i++) \n\t    { \n\t        if (cost[i]!= -1) \n\t        { \n\t            val.push_back(cost[i]); \n\t            wt.push_back(i+1); \n\t            size++; \n\t        } \n\t    } \n\t  \n\t    N = size; \n\t    int min_cost[N+1][W+1]; \n\t  \n\t    // fill 0th row with infinity \n\t    for (int i=0; i<=W; i++) \n\t        min_cost[0][i] = INF; \n\t  \n\t    // fill 0'th column with 0 \n\t    for (int i=1; i<=N; i++) \n\t        min_cost[i][0] = 0; \n\t  \n\t    // now check for each weight one by one and fill the \n\t    // matrix according to the condition \n\t    for (int i=1; i<=N; i++) \n\t    { \n\t        for (int j=1; j<=W; j++) \n\t        { \n\t            // wt[i-1]>j means capacity of bag is \n\t            // less then weight of item \n\t            if (wt[i-1] > j) \n\t                min_cost[i][j] = min_cost[i-1][j]; \n\t  \n\t            // here we check we get minimum cost either \n\t            // by including it or excluding it \n\t            else\n\t                min_cost[i][j] = min(min_cost[i-1][j], \n\t                     min_cost[i][j-wt[i-1]] + val[i-1]); \n\t        } \n\t    } \n\t  \n\t    // exactly weight W can not be made by given weights \n\t    return (min_cost[N][W]==INF)? -1: min_cost[N][W]; \n\t} \n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/close-to-perfection1525/1", "editorial": "//Back-end complete function template in C++\n\nclass Solution {\n  public:\n    //Function to find the length of the longest subarray with consecutive elements.\n    int longestPerfectPiece(int arr[], int N) {\n        \n        //creating a multiset to store unique elements of the subarray.\n        multiset<int> s;\n        \n        //variable to store the maximum length of the subarray.\n        int ans = 0;\n        \n        //iterating over the given array.\n        for(int i=0, j=0; i<N; i++)\n        {\n            //inserting the current element in the set.\n            s.insert(arr[i]);\n            \n            //checking if the difference between the maximum and minimum element\n            //in the set is greater than 1.\n            while (*s.rbegin() - *s.begin() > 1)\n                //erasing the first element in the set and moving the pointer.\n                s.erase(s.find(arr[j++]));\n            \n            //updating the maximum length of the subarray.\n            ans = max(ans, (int)s.size());\n        }\n        \n        //returning the maximum length of the subarray.\n        return ans;\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/sum-of-all-substrings-of-a-number-1587115621/1", "editorial": "class Solution\n{\n    //Function to find sum of all possible substrings of the given string.\n    public static long sumSubstrings(String s)\n    {\n     int n = s.length();\n \n        // Storing prev value\n        long prev = toDigit(s.charAt(0));\n \n        long res = prev;\n \n        long current = 0;\n \n        // SubStrings sum upto current index\n        // loop over all digits of String\n        for (int i = 1; i < n; i++) {\n            long numi = toDigit(s.charAt(i));\n \n            // Update each sumofdigit\n            // from previous value\n            current = ((i + 1) * numi)%1000000007 + (10 * prev)%1000000007;\n \n            // Add current value to the result\n            res += current;\n \n            // Update previous\n            prev = current;\n        }\n        return res%1000000007;\n    }\n       static long toDigit(char ch) { return (ch - '0'); }\n \n  \n}"}
{"urls": "https://practice.geeksforgeeks.org/problems/count-palindromic-subsequences/1", "editorial": "class Solution {\npublic:\n    const long long int mod = 1000000007;\n    long long int add(long long int x, long long int y) {\n        return ((x % mod) + (y % mod)) % mod;\n    }\n    long long int sub(long long int x, long long int y) {\n        return ((x % mod) - (y % mod) + mod) % mod;\n    }\n    long long int  countPS(string str)\n    {\n        long long int  N = str.length();\n\n        // create a 2D array to store the count of palindromic\n        // subsequence\n        long long int  cps[N + 1][N + 1];\n        memset(cps, 0 , sizeof(cps));\n\n        // palindromic subsequence of length 1\n        for (long long int  i = 0; i < N; i++)\n            cps[i][i] = 1;\n\n        // check subsequence of length L is palindrome or not\n        for (long long int  L = 2; L <= N; L++)\n        {\n            for (long long int  i = 0; i <= N - L; i++)\n            {\n                long long int  k = L + i - 1;\n                if (str[i] == str[k])\n                    cps[i][k] = add(cps[i][k - 1] , add(cps[i + 1][k] , 1LL)) % mod;\n                else\n                    cps[i][k] = add(cps[i][k - 1] , sub(cps[i + 1][k] , cps[i + 1][k - 1])) % mod;\n            }\n        }\n\n        // return total palindromic subsequence\n        return cps[0][N - 1] % mod;\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/pizza-mania0155/1", "editorial": "int cache[50001][501];\n\nclass Solution {\n  public:\n\n    int dp(int currcost, int X, int S, int M, int L, int CS, int CM, int CL) {\n        \n        if(X <= 0)\n            return currcost;\n        \n        if(cache[currcost][X] != -1)\n            return cache[currcost][X];\n            \n        int ans1 = 10000000;\n        int ans2 = ans1, ans3 = ans1;\n        \n        ans1 = dp(currcost+CS, X-S, S, M, L, CS, CM, CL);    // if a Small Pizza is taken next\n        ans2 = dp(currcost+CM, X-M, S, M, L, CS, CM, CL);    // if a Medium Pizza is taken next\n        ans3 = dp(currcost+CL, X-L, S, M, L, CS, CM, CL);    // if a Large Pizza is taken next\n        \n        cache[currcost][X] = min(ans1, min(ans2, ans3));\n            \n        return min(ans1, min(ans2, ans3));\n    }\n    \n    int getPizza(int X, int S, int M, int L, int CS, int CM, int CL) {\n        \n        memset(cache,-1,sizeof(cache));\n        \n        return (dp(0,X,S,M,L,CS,CM,CL));\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/convert-to-strictly-increasing-array3351/1", "editorial": "class Solution {\n  public:\n\n    int min_operations(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> dp(n, 1);\n        for (int i = 1; i < n; i++) {\n            int temp = 0;\n            for (int j = 0; j < i; j++) {\n                // If nums[i] is greater than nums[j] then it can be added to the set of\n                // LIS\n                if (nums[i] > nums[j])\n                    if (nums[i] - nums[j] > i - j - 1)\n                        temp = max(temp, dp[j]);\n            }\n            // length of maximum increasing subsequnce whose last element is nums[i]\n            dp[i] = max(dp[i], 1 + temp);\n        }\n        // total opeartion needs to  apply\n        return n - *max_element(dp.begin(), dp.end());\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/-minimum-number-of-coins4426/1", "editorial": "// Back-end complete function Template for C++\n\nclass Solution{\npublic:\n    // Function to find the minimum partition of a given number N\n    vector<int> minPartition(int N)\n    {\n        // Array to store the minimum number of coins required for each value\n        int dp[N+1], dp2[N+1];\n        \n        // Array to store the denominations of the coins available\n        int a[10] = {1, 2, 5, 10, 20, 50, 100, 200, 500, 2000};\n        \n        // Initializing the base case\n        dp[0] = 0;\n        dp2[0] = 0;\n        \n        // Initializing other values with maximum value and -1\n        for(int i = 1;i <= N;i++){\n            dp[i] = INT_MAX;\n            dp2[i] = -1;\n        }\n        \n        // Dynamic programming approach to find the minimum number of coins\n        for(int j = 0;j < 10;j++){\n            for(int i = 0;i <= N;i++){\n                // Checking if the current coin is smaller than or equal to the value\n                if(i >= a[j]){\n                    // Updating the minimum number of coins required and the coin used\n                    dp[i] = min(dp[i], 1+ dp[i-a[j]]);\n                    dp2[i] = j;\n                }\n            }\n        }\n        \n        // Constructing the list of coins used to get the minimum number of coins required\n        int k = N;\n        vector<int> v;\n        for(int i = N;i > 0 && N >= 0;){\n            if(dp2[i] != -1)\n                v.push_back(a[dp2[i]]);\n            N = N - a[dp2[i]];\n            i = N;\n        }\n        \n        // Returning the list of coins used\n        return v;\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/subset-sum-problem2014/1", "editorial": "// Back-end complete function Template for C++\n\nclass Solution{\npublic:\n    // Function to calculate if it is possible to partition the array equally.\n    int cal(int node, int a[], int cur, int sum, int n, vector<vector<int>> &dp)\n    {\n        // Base case: if we have reached the end of the array,\n        // check if current sum is equal to half of the total sum.\n        if(node >= n){\n            if(cur*2 != sum) \n                return 0;\n            else \n                return 1;\n        }\n        \n        // If current sum is greater than total sum, return 0.\n        if(cur*2 > sum) \n            return dp[node][cur] = 0;\n        \n        // If current sum is equal to half of total sum, return 1.\n        if(cur*2 == sum) \n            return dp[node][cur] = 1;\n        \n        // If the subproblem has already been solved, return the result.\n        if(dp[node][cur] != -1) \n            return dp[node][cur];\n        \n        // Recursive call to check if it is possible to partition the array\n        // by either including the current element or excluding it.\n        int f = 0;\n        f = cal(node+1, a, cur+a[node], sum, n, dp) | cal(node+1, a, cur, sum, n, dp);\n        \n        return dp[node][cur] = f;\n    }\n    \n    // Function to check if array can be partitioned equally.\n    int equalPartition(int N, int arr[])\n    {\n        // Calculating the total sum of the array.\n        int sum = 0;\n        for(int i = 0;i < N;i++)\n            sum += arr[i];\n        \n        // Creating a 2D vector to store the results of subproblems.\n        vector<vector<int>> dp(N, vector<int>(sum+1, -1));\n        \n        // Calling the helper function to check if array can be partitioned equally.\n        int x = cal(0, arr, 0, sum, N, dp);\n        \n        return x;\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/minimum-number-of-deletions-and-insertions0209/1", "editorial": "class Solution{\n\t\t\n\n\tpublic:\n\tint minOperations(string str1, string str2) \n\t{ \n\t    int m = str1.size();\n\t    int n = str2.size();\n\t    \n\t    int L[m+1][n+1]; \n\t   \tint i, j; \n\t    \n\t   \t// Following steps build L[m+1][n+1] in bottom \n\t   \t// up fashion. Note that L[i][j] contains  \n\t   \t// length of LCS of str1[0..i-1] and str2[0..j-1]  \n\t   \tfor (i=0; i<=m; i++) \n\t   \t{ \n\t     \tfor (j=0; j<=n; j++) \n\t     \t{\t \n\t      \t\tif (i == 0 || j == 0) \n\t         \t\tL[i][j] = 0; \n\t    \n\t       \t\telse if (str1.at(i-1) == str2.at(j-1)) \n\t         \t\tL[i][j] = L[i-1][j-1] + 1; \n\t    \n\t       \t\telse\n\t         \t\tL[i][j] = max(L[i-1][j], L[i][j-1]); \n\t     \t} \n\t   \t} \n\t      \n\t   \t// L[m][n] contains length of LCS  \n\t   \t// for X[0..n-1] and Y[0..m-1]  \n\t   \treturn m + n - 2*L[m][n];\n\t} \n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/probability-of-knight5529/1", "editorial": "class Solution{\n\tpublic:\n\t// direction vector for the Knight\n\tvector<int>dx = { 1, 2, 2, 1, -1, -2, -2, -1};\n\tvector<int>dy = { 2, 1, -1, -2, -2, -1, 1, 2};\n\t \n\t// returns true if the knight is inside the chessboard\n\tbool inside(int N,int x, int y)\n\t{\n\t    return (x >= 0 and x < N and y >= 0 and y < N);\n\t}\n\t \n\t// Bottom up approach for finding the probability to\n\t// go out of chessboard.\n\tdouble findProb(int N,int start_x, int start_y, int steps)\n\t{\n\t    // dp array\n\t    double dp1[N][N][N];\n\t \n\t    // for 0 number of steps, each position\n\t    // will have probability 1\n\t    for (int i = 0; i < N; ++i)\n\t        for (int j = 0; j < N; ++j)\n\t            dp1[i][j][0] = 1;\n\t \n\t    // for every number of steps s\n\t    for (int s = 1; s <= steps; ++s)\n\t    {\n\t        // for every position (x,y) after\n\t        // s number of steps\n\t        for (int x = 0; x < N; ++x)\n\t        {\n\t            for (int y = 0; y < N; ++y)\n\t            {\n\t                double prob = 0.0;\n\t \n\t                // for every position reachable from (x,y)\n\t                for (int i = 0; i < 8; ++i)\n\t                {\n\t                    int nx = x + dx[i];\n\t                    int ny = y + dy[i];\n\t \n\t                    // if this position lie inside the board\n\t                    if (inside(N,nx, ny))\n\t                        prob += dp1[nx][ny][s-1] / 8.0;\n\t                }\n\t \n\t                // store the result\n\t                dp1[x][y][s] = prob;\n\t            }\n\t        }\n\t    }\n\t \n\t    // return the result\n\t    return dp1[start_x][start_y][steps];\n\t}\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/wildcard-pattern-matching/1", "editorial": "// C++ program to implement wildcard\n// pattern matching algorithm\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function that matches input str with\n// given wildcard pattern\nbool strmatch(char str[], char pattern[], int n, int m)\n{\n    // empty pattern can only match with\n    // empty string\n    if (m == 0)\n        return (n == 0);\n\n    // lookup table for storing results of\n    // subproblems\n    bool lookup[n + 1][m + 1];\n\n    // initialize lookup table to false\n    memset(lookup, false, sizeof(lookup));\n\n    // empty pattern can match with empty string\n    lookup[0][0] = true;\n\n    // Only '*' can match with empty string\n    for (int j = 1; j <= m; j++)\n        if (pattern[j - 1] == '*')\n            lookup[0][j] = lookup[0][j - 1];\n\n    // fill the table in bottom-up fashion\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            // Two cases if we see a '*'\n            // a) We ignore ‘*’ character and move\n            //    to next  character in the pattern,\n            //     i.e., ‘*’ indicates an empty sequence.\n            // b) '*' character matches with ith\n            //     character in input\n            if (pattern[j - 1] == '*')\n                lookup[i][j]\n                    = lookup[i][j - 1] || lookup[i - 1][j];\n\n            // Current characters are considered as\n            // matching in two cases\n            // (a) current character of pattern is '?'\n            // (b) characters actually match\n            else if (pattern[j - 1] == '?'\n                     || str[i - 1] == pattern[j - 1])\n                lookup[i][j] = lookup[i - 1][j - 1];\n\n            // If characters don't match\n            else\n                lookup[i][j] = false;\n        }\n    }\n\n    return lookup[n][m];\n}\n\nint main()\n{\n    char str[] = \"baaabab\";\n    char pattern[] = \"*****ba*****ab\";\n    // char pattern[] = \"ba*****ab\";\n    // char pattern[] = \"ba*ab\";\n    // char pattern[] = \"a*ab\";\n    // char pattern[] = \"a*****ab\";\n    // char pattern[] = \"*a*****ab\";\n    // char pattern[] = \"ba*ab****\";\n    // char pattern[] = \"****\";\n    // char pattern[] = \"*\";\n    // char pattern[] = \"aa?ab\";\n    // char pattern[] = \"b*b\";\n    // char pattern[] = \"a*a\";\n    // char pattern[] = \"baaabab\";\n    // char pattern[] = \"?baaabab\";\n    // char pattern[] = \"*baaaba*\";\n\n    if (strmatch(str, pattern, strlen(str),\n                 strlen(pattern)))\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n\n    return 0;\n}"}
{"urls": "https://practice.geeksforgeeks.org/problems/minimum-steps-to-delete-a-string2956/1", "editorial": "class Solution{\n\n\tpublic:\n\tint minStepToDeleteString(string str) \n\t{ \n\t    int N = str.length(); \n\t  \n\t    //  declare dp array and initialize it with 0s \n\t    int dp[N + 1][N + 1]; \n\t    for (int i = 0; i <= N; i++) \n\t        for (int j = 0; j <= N; j++) \n\t            dp[i][j] = 0; \n\t  \n\t    // loop for substring length we are considering \n\t    for (int len = 1; len <= N; len++) \n\t    { \n\t        // loop with two variables i and j, denoting \n\t        // starting and ending of substrings \n\t        for (int i = 0, j = len - 1; j < N; i++, j++) \n\t        { \n\t            // If substring length is 1, then 1 step \n\t            // will be needed \n\t            if (len == 1) \n\t                dp[i][j] = 1; \n\t            else\n\t            { \n\t                // delete the ith char individually \n\t                // and assign result for subproblem (i+1,j) \n\t                dp[i][j] = 1 + dp[i + 1][j]; \n\t  \n\t                // if current and next char are same, \n\t                // choose min from current and subproblem \n\t                // (i+2,j) \n\t                if (str[i] == str[i + 1]) \n\t                    dp[i][j] = min(1 + dp[i + 2][j], dp[i][j]); \n\t  \n\t                /*  loop over all right characters and suppose \n\t                    Kth char is same as ith character then \n\t                    choose minimum from current and two \n\t                    substring after ignoring ith and Kth char */\n\t                for (int K = i + 2; K <= j; K++) \n\t                    if (str[i] == str[K]) \n\t                        dp[i][j] = min(dp[i+1][K-1] + dp[K+1][j], \n\t                                                       dp[i][j]); \n\t            } \n\t        } \n\t    } \n\t  \n\t    /* Uncomment below snippet to print actual dp tablex \n\t    for (int i = 0; i < N; i++, cout << endl) \n\t        for (int j = 0; j < N; j++) \n\t            cout << dp[i][j] << \" \";    */\n\t  \n\t    return dp[0][N - 1]; \n\t} \n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/count-ways-to-nth-stairorder-does-not-matter1322/1", "editorial": "class Solution {\n  public:\n    // Function to count number of ways to reach the nth stair\n    // when order does not matter.\n    long long countWays(int n) {\n        long long res[n + 1];\n\n        // base cases\n        res[0] = 1;\n        res[1] = 1;\n\n        // storing number of ways to reach the ith index as\n        // number of ways to reach (i-2)th index +1.\n        for (int i = 2; i <= n; i++)\n            res[i] = (res[i - 2] + 1);\n\n        // returning the result.\n        return res[n];\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/minimum-steps1159/1", "editorial": "// including necessary header files and defining the macro\n#define ll long long\n\n// creating a class called Solution\nclass Solution{\n    public:\n        // function to calculate the minimum moves required\n        int moves(int n, int p, int q)\n    {\n        // creating a vector to store the sequence of powers of p and q\n        vector<ll> a;\n\n        // initializing variables\n        ll i,j,tempp,tempq;\n\n        // multiplying p and q by 1000000 if they are equal to 1\n        if(p==1)\n            p*=1000000;\n        if(q==1)\n            q*=1000000;\n\n        // setting initial values in the sequence\n        tempp=p;\n        tempq=q;\n\n        a.push_back(1);\n\n        // generating the sequence\n        while(tempp<=n || tempq<=n)\n        {\n            if(tempp<tempq){\n                a.push_back(tempp);\n                tempp*=p;\n            }\n            else\n            {\n                a.push_back(tempq);\n                tempq*=q;\n            }\n        }\n\n        // creating a 2D array to store the results\n        ll dp[a.size()+1][n+1];\n\n        // initializing the array with a large value\n        for(i=0;i<=a.size();i++)\n            for(j=0;j<=n;j++)\n                dp[i][j]=99999999;\n\n        // setting initial values in the array\n        for(i=0;i<=a.size();i++)\n            dp[i][0]=0;\n\n        // calculating the minimum moves required using dynamic programming\n        for(j=0;j<=n;j++){\n            for(i=1;i<=a.size();i++){\n                dp[i][j]=dp[i-1][j];\n                if(a[i-1]<=j)\n                    dp[i][j]=min( (dp[i][j-a[i-1]])+1 , (dp[i-1][j]) );\n            }\n        }\n\n        // returning the minimum moves required\n        return dp[a.size()][n];\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/skip-the-work5752/1", "editorial": "class Solution\n{\n  public:\n    //Function to find the minimum amount required.\n    int minAmount(int A[] , int N)\n    {\n        //iterating from 2nd index to N-1th index\n        for(int i=2;i<N;i++)\n        {\n            //Adding the minimum of previous two elements to the current element.\n            A[i]=A[i]+min(A[i-1],A[i-2]);\n        }\n        // returning minimum of last and second last element.\n        return min( A[N -1] , A[N  - 2]);    \n    }"}
{"urls": "https://practice.geeksforgeeks.org/problems/levels-of-game/1", "editorial": "class Solution {\npublic:\n\n    int maxLevel(int h, int m) {\n        // Initialize dp with reduced dimensions based on constraints\n      int road_1=0,road_2=0,road_3=0;\n            int count=0;\n            while((road_1==0 && h>20) || (road_2==0 && h>5 && m>10) || (road_3==0))\n            {\n                if(road_3==0){\n                      h+=3;\n                    m+=2;\n                     road_1=0;\n                    road_2=0;\n                    road_3=1;\n                    count++;\n                \n                }\n                else if(h>5 && m>10 && road_2==0)\n                {\n                   \n                     h-=5;\n                    m-=10;\n                     road_1=0;\n                    road_2=1;\n                    road_3=0;\n                    count++;\n                }\n                else if(h>20 && road_1==0){\n                    h-=20;\n                    m+=5;\n                    road_1=1;\n                    road_2=0;\n                    road_3=0;\n                    count++;\n                }\n                \n                else\n                {\n                    if(road_3==0){\n                    h+=3;\n                    m+=2;\n                     road_1=0;\n                    road_2=0;\n                    road_3=1;\n                    count++;\n                    }\n                    else{\n                        break;\n                    }\n                }\n            }\n            return count;\n        }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/telephone-number-or-involution-number4412/1", "editorial": "// Back-end complete function Template for C++\n\nclass Solution{\npublic:\n    // Function to count the number of telephone numbers\n    long long telephoneNum(long long n){\n        long long mod = 1000000007LL;\n        long long dp[n+1]; // array to store the number of telephone numbers\n        memset(dp, 0, sizeof(dp)); // initializing the array with all zeros\n        dp[0] = dp[1] = 1; // base case: there is only one telephone number for n = 0 or 1\n        // looping through the array to calculate the number of telephone numbers for each n\n        for(long long i = 2;i <= n;i++) {\n            dp[i] = (dp[i-1]%mod + ((i-1)*dp[i-2])%mod)%mod; // calculating the number of telephone numbers using recurrence relation\n        }\n        return dp[n]; // returning the number of telephone numbers for n\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/nth-catalan-number0817/1", "editorial": "class Solution\n{\n    public:\n    //Function to find the nth catalan number.\n    int findCatalan(int n) \n    {\n        //base case\n        if(n==0 || n==1){\n            return 1;\n        }\n        \n        long long dp[n+1],mod=1e9+7;\n        // Initializing dp[0] and dp[1] as 1\n        dp[0]=dp[1]=1;\n        \n        for(int i=2;i<=n;i++){\n            dp[i]=0;\n            for(int j=0;j<i;j++){\n                dp[i] = (dp[i]+(dp[j]*dp[i-j-1])%mod)%mod;\n            }\n        }\n        \n        //returning the nth catalan number.\n        return dp[n];\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/ncr1019/1", "editorial": "class Solution:\n    def nCr(self, n, r):\n        def fact(num):\n            ans=1\n            for i in range(1, num+1):\n                ans*=i\n            return ans\n        return (fact(n)//(fact(r)*fact(n-r)))%(10**9+7)\n             "}
{"urls": "https://practice.geeksforgeeks.org/problems/longest-palindromic-subsequence-1612327878/1", "editorial": "//Back-end complete function Template for C++\n\nclass Solution{\n  public:\n    int longestPalinSubseq (string A)\n    {\n        int n = A.length ();\n        string B = A;\n        reverse (B.begin(), B.end());\n        \n        // a palindrome reads the same from front and reverse.\n        // hence, the longest palindromic subsequence is\n        // basically the longest common subsequence in\n        // A and reverse(A)\n        int dp[n + 1][n + 1];\n        for (int i = 0; i <= n; ++i)\n        {\n            for (int j = 0; j <= n; ++j)\n            {\n                if (i == 0 || j == 0) dp[i][j] = 0;\n                else\n                {\n                    if (A[i - 1] == B[j - 1])\n                        dp[i][j] = 1 + dp[i - 1][j - 1];\n                    else\n                        dp[i][j] = max (dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[n][n];\n    }\n};\n// Contributed By: Pranay Bansal"}
{"urls": "https://practice.geeksforgeeks.org/problems/minimum-four-sum-subsequence/1", "editorial": "//Back-end complete function template in C++\n\nclass Solution{\n\n    public:\n    //Function to find the minimum sum of elements.\n    int minSum(int arr[], int n)\n    {\n\n    //creating an array to store the minimum sum values.\n    int dp[n];\n \n\n    //checking for base conditions if n is less than or equal to 4.\n    if (n==1)\n        return arr[0];\n\n    if (n==2)\n        return min(arr[0], arr[1]);\n\n    if (n==3)\n        return min(arr[0], min(arr[1], arr[2]));\n \n    if (n==4)\n        return min(min(arr[0], arr[1]),\n                   min(arr[2], arr[3]));\n \n    //initializing the dp array with values of first 4 elements.\n    dp[0] = arr[0];\n    dp[1] = arr[1];\n    dp[2] = arr[2];\n    dp[3] = arr[3];\n \n    //iterating through the array to find the minimum sum values.\n    for (int i=4; i<n; i++)\n        dp[i] = arr[i] +\n                   min(min(dp[i-1], dp[i-2]),\n                       min(dp[i-3], dp[i-4]));\n \n    //returning the minimum sum value.\n    return min(min(dp[n-1], dp[n-2]),\n               min(dp[n-4], dp[n-3]));\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/7e5ec07f9d865297cff9a91522c2ce805433b420/1", "editorial": "class Solution{\npublic:\n    // Function to find the maximum score starting from given position\n    int knightInGeekland(int start_x,int start_y,vector<vector<int>> &arr){\n        int n=arr.size(); // number of rows\n        int m=arr[0].size(); // number of columns\n        \n        vector<vector<int>> vis(n,vector<int>(m)); // create a visited matrix to keep track of visited positions\n        vis[start_x][start_y] = 1; // mark the starting position as visited\n        queue<pair<int,int>> q; // create a queue to perform breadth-first search\n        q.push({start_x, start_y}); // push the starting position into the queue\n        \n        vector<int> list; // create a list to store the score obtained at each level\n        int points = 0; // initialize the points to 0\n        \n        int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2}; // array to store possible x-direction moves\n        int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1}; // array to store possible y-direction moves\n        \n        // helper function to check if the given position is safe or not\n        auto isSafe=[&](int i, int j){\n            return (i>=0 and j>=0 and i<n and j<m); // returns true if the position is within the matrix bounds\n        };\n        \n        while(q.size()){ // while the queue is not empty\n            \n            int size = q.size(); // get the current size of the queue\n           \n            points = 0; // reset the points for each level\n            \n            for(int i = 0; i < size; i++){ // process all the elements in the current level\n                auto tmp = q.front(); // get the front element\n                q.pop(); // remove the front element from the queue\n                int x = tmp.first, y = tmp.second; // get the x and y coordinates\n                \n                points += arr[x][y]; // add the score at the current position to the points\n                \n                // check all possible moves from the current position\n                for(int k = 0; k < 8; k++){\n                    int xi = x + dx[k]; // get the new x coordinate\n                    int xj = y + dy[k]; // get the new y coordinate\n                    \n                    // if the new position is safe and not visited, mark it as visited and push it into the queue\n                    if(isSafe(xi, xj) && !vis[xi][xj]){\n                        vis[xi][xj] = 1; // mark the new position as visited\n                        q.push({xi, xj}); // push the new position into the queue\n                    }\n                }\n            }\n            list.push_back(points); // add the points obtained at the current level to the list\n        }\n        \n        int max = -1, ans = -1; // variables to store the maximum score and the answer position\n        \n        // iterate backwards through the list\n        for(int i = list.size() - 1; i >= 0; i--){\n            \n            // if the next position is within the list bounds, add it to the current score\n            if(list[i] + i < list.size())\n                list[i]+=list[i + list[i]];\n        }\n        \n        // find the maximum score and its position\n        for(int i = 0; i < list.size(); i++){\n            if(list[i] > max){\n                max = list[i]; // update the maximum score\n                ans = i; // update the answer position\n            }\n        }\n        return ans; // return the answer position\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/palindromic-strings2555/1", "editorial": "class Solution{\n\n\tprivate:\n\t//Function to calculate the length of the Longest Common Subsequence (LCS) \n\t//between two strings X and Y.\n\tint lcs(string X, string Y)  \n\t{  \n\t\tint n = X.size(), m = n;\n\n\t\t//Creating a 2D array L to store the length of the LCS.\n\t    int L[m + 1][n + 1];  \n\t    int i, j;  \n\n\t    //Initializing the first row and column of L as 0.\n\t    for (i = 0; i <= m; i++)  \n\t    {  \n\t        for (j = 0; j <= n; j++)  \n\t        {  \n\t\t        if (i == 0 || j == 0)  \n\t\t            L[i][j] = 0;\n\n\t\t        //If the corresponding characters from X and Y are equal, \n\t\t        //increment the LCS length by 1.\n\t\t        else if (X[i - 1] == Y[j - 1])  \n\t\t            L[i][j] = L[i - 1][j - 1] + 1;\n\n\t\t        //If the characters are not equal, take the maximum length \n\t\t        //from the previous row or column.\n\t\t        else\n\t\t            L[i][j] = max(L[i - 1][j], L[i][j - 1]);  \n\t        }  \n\t    }  \n\n\t    //Returning the length of the LCS for X and Y.\n\t    return L[m][n];  \n\t}  \n\n\tpublic:\n\t//Function to check if it is possible to make the given string a \n\t//palindrome by changing at most K characters.\n\tint isPossiblePalindrome(string str, int K)\n\t{\n\t    //Creating a reverse string of the given string.\n\t    string rev_str = str;\n\t    reverse(rev_str.begin(), rev_str.end());\n\n\t    //Calculating the length of the LCS between the given string and its reverse.\n\t    int lcs_len = lcs(str, rev_str);\n\n\t    int n = str.size();\n\n\t    //If K is less than the difference between the length of the string \n\t    //and the length of the LCS, it is not possible to make it a palindrome.\n\t    if(K < (n - lcs_len))\n\t    \treturn 0;\n\n\t    //Otherwise, it is possible to make it a palindrome by changing at most K characters.\n\t    return 1;\n\t}\n\t  \n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/count-number-of-substrings4528/1", "editorial": "//Backend complete function template for C++\n\nclass Solution\n{\n  public:\n    long long int atMostK (string s, int k)\n    {\n    \tif (k < 0) return 0;\n    \n    \tint i = 0, j = 0, cnt = 0;\n    \tlong long int res = 0;\n    \tint m[26] = {0};\n    \n    \twhile (j < s.length ())\n    \t{\n    \t\tm[s[j] - 'a']++;\n    \t\tif (m[s[j] - 'a'] == 1) cnt++;\n    \n    \t\twhile (cnt > k)\n    \t\t{\n    \t\t\tm[s[i] - 'a']--;\n    \t\t\tif (m[s[i] - 'a'] == 0) cnt--;\n    \n    \t\t\ti++;\n    \t\t}\n    \n    \t\tres += (j - i + 1);\n    \t\tj++;\n    \t}\n    \treturn res;\n    }\n\n    long long int substrCount (string s, int k) {\n    \treturn atMostK (s, k) - atMostK (s, k - 1);\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/number-of-coins1824/1", "editorial": "class Solution{\n\n\tpublic:\n\tint minCoins(vector<int> &coins, int M, int V) \n\t{ \n\t    // table[i] will be storing the minimum number of coins \n\t    // required for i value.  So table[V] will have result \n\t    int table[V+1]; \n\t  \n\t    // Base case (If given value V is 0) \n\t    table[0] = 0; \n\t  \n\t    // Initialize all table values as Infinite \n\t    for (int i=1; i<=V; i++) \n\t        table[i] = INT_MAX; \n\t  \n\t    // Compute minimum coins required for all \n\t    // values from 1 to V \n\t    for (int i=1; i<=V; i++) \n\t    { \n\t        // Go through all coins smaller than i \n\t        for (int j=0; j<M; j++) \n\t        {\n\t          \tif (coins[j] <= i) \n\t          \t{ \n\t              \tint sub_res = table[i-coins[j]]; \n\t              \tif(sub_res != INT_MAX && sub_res + 1 < table[i]) \n\t                  \ttable[i] = sub_res + 1; \n\t          \t}\n\t        } \n\t    } \n\n\t    if(table[V]==INT_MAX)\n\t    \treturn -1;\n\n\t    return table[V]; \n\t} \n\t  \n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/maximum-sum-of-elements-not-part-of-lis/1", "editorial": "class Solution {\n  public:\n    int maxSumLis(int Arr[], int n) {\n        int totalSum = 0;\n\n        // Find total sum of array\n        for (int i = 0; i < n; i++) {\n            totalSum += Arr[i];\n        }\n\n        // Maintain a 2D array\n        int dp[2][n];\n        for (int i = 0; i < n; i++) {\n            dp[0][i] = 1;\n            dp[1][i] = Arr[i];\n        }\n\n        // Update the dp array along\n        // with sum in the second row\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (Arr[i] > Arr[j]) {\n                    // In case of greater length\n                    // Update the length along\n                    // with sum\n                    if (dp[0][i] < dp[0][j] + 1) {\n                        dp[0][i] = dp[0][j] + 1;\n                        dp[1][i] = dp[1][j] + Arr[i];\n                    }\n\n                    // In case of equal length\n                    // find length update length\n                    // with minimum sum\n                    else if (dp[0][i] == dp[0][j] + 1) {\n                        dp[1][i] = min(dp[1][i], dp[1][j] + Arr[i]);\n                    }\n                }\n            }\n        }\n        int maxm = 0;\n        int subtractSum = 0;\n\n        // Find the sum that need to\n        // be subtracted from total sum\n        for (int i = 0; i < n; i++) {\n            if (dp[0][i] > maxm) {\n                maxm = dp[0][i];\n                subtractSum = dp[1][i];\n            } else if (dp[0][i] == maxm) {\n                subtractSum = min(subtractSum, dp[1][i]);\n            }\n        }\n\n        // Return the sum\n        return totalSum - subtractSum;\n    }\n};"}
{"urls": "https://practice.geeksforgeeks.org/problems/maximum-tip-calculator2631/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/count-ways-to-express-n-as-the-sum-of-13-and-44024/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/optimal-walk3752/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/unique-bsts-1587115621/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/largest-square-in-a-binary-matrix-with-at-most-k-1s-for-multiple-queries/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/word-break1352/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/array-partition/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/high-effort-vs-low-effort0213/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/longest-increasing-subsequence-1587115620/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/count-all-possible-paths-from-top-left-to-bottom-right3011/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/brackets-in-matrix-chain-multiplication1024/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/minimum-deletitions1648/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/maximum-calorie0056/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/get-minimum-squares0538/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/number-of-permutation-with-k-inversions5304/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/7366ce450d84b55391fc787a681c4d60de359e72/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/snake-and-ladder-problem4816/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/stock-buy-and-sell-1587115621/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/find-optimum-operation4504/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/largest-square-formed-in-a-matrix0806/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/lcs-of-three-strings0028/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/minimum-points-to-reach-destination0540/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/check-if-any-valid-sequence-is-divisible-by-m1114/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/count-of-n-digit-numbers-whose-sum-of-digits-equals-to-given-sum0733/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/paths-to-reach-origin3850/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/better-string/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/minimum-number-of-steps-to-reach-a-given-number5234/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/temple-offerings2831/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/largest-zigzag-sequence5416/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/compute-sum-of-digits-in-all-numbers-from-1-to-n2855/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/interleaved-strings/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/largest-rectangular-sub-matrix-whose-sum-is-0/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/little-murph-and-knots0402/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/count-the-number-of-ways-to-tile-the-floor-of-size-n-x-m-using-1-x-m-size-tiles0509/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/maximum-profit4657/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/number-formation3506/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/edit-distance3702/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/longest-repeating-and-non-overlapping-substring3421/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/ways-to-write-n-as-sum-1587115621/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/00ae30d0e0f6d8877c68f8b8558c5b0138fdb4b7/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/aa0000a5f710ce8d41366b714341eef644ec7b82/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/gold-mine-problem2608/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/count-of-ap-subsequences0016/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/count-in-array2138/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/reach-a-given-score-1587115621/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/form-a-palindrome2544/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/longest-common-increasing-subsequence1437/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/find-if-string-is-k-palindrome-or-not1923/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/path-in-matrix3805/1", "editorial": ""}
{"urls": "https://practice.geeksforgeeks.org/problems/minimum-number-of-elements-which-are-not-part-of-increasing-or-decreasing-subsequence2617/1", "editorial": ""}
