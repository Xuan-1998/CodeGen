{"statement": "Task: Given a regular polygon with $n$ vertices labeled from $1$ to $n$ in counter-clockwise order, find the minimum weight among all possible triangulations of the polygon. The weight of a triangulation is the sum of weights of all triangles it consists of, where the weight of a triangle is the product of labels of its vertices.\n\nInput: The input consists of a single integer $n$ ($3 \\le n \\le 500$) representing the number of vertices in the regular polygon. The input is provided through standard input.\n\nOutput: The output consists of a single integer representing the minimum weight among all possible triangulations of the given polygon.\n\nConstraints: The input integer $n$ must be greater than or equal to 3 and less than or equal to 500.", "editorial": "", "tag": "['Dynamic programming', 'Mathematics', 'Greedy algorithms']", "difficulties": "EASY", "source": "codeforces", "url": "https://codeforces.com/problemset/problem/1140/D", "sample_test_cases": [{"input": "3\n", "output": "6\n"}, {"input": "4\n", "output": "18\n"}, {"input": "5\n", "output": "38\n"}, {"input": "6\n", "output": "68\n"}, {"input": "7\n", "output": "110\n"}]}
{"statement": "Task: Given a binary table with two rows of equal length, partition it into any number of consecutive bi-tables and find the maximal sum of the smallest digit that does not occur in each bi-table.\n\nInput: The input consists of multiple test cases. For each test case, the first line contains a single integer $n$ ($1 \\le n \\le 10^5$) \u2014 the number of columns in the bi-table. Each of the next two lines contains a binary string of length $n$ \u2014 the rows of the bi-table. Input is provided through standard input.\n\nOutput: For each test case, output a single integer \u2014 the maximal sum of the smallest digit that does not occur in each bi-table obtained by cutting the given bi-table optimally.\n\nConstraints: The sum of $n$ over all test cases does not exceed $10^5$.", "editorial": "", "tag": "['Dynamic programming', 'Bit manipulation', 'Constructive algorithms', 'Greedy algorithms']", "difficulties": "EASY", "source": "codeforces", "url": "https://codeforces.com/problemset/problem/1566/C", "sample_test_cases": [{"input": "4\n7\n0101000\n1101100\n5\n01100\n10101\n2\n01\n01\n6\n000000\n111111\n", "output": "8\n8\n2\n12\n"}, {"input": "4\n7\n0101000\n1101100\n5\n01100\n10101\n2\n01\n01\n6\n000100\n111111\n", "output": "8\n8\n2\n10\n"}, {"input": "4\n7\n0101000\n1101100\n5\n01000\n10101\n2\n01\n01\n6\n000000\n111111\n", "output": "8\n9\n2\n12\n"}, {"input": "4\n7\n0101000\n1100100\n5\n01100\n10101\n2\n01\n01\n6\n000100\n111111\n", "output": "10\n8\n2\n10\n"}, {"input": "4\n7\n0101000\n1101100\n5\n01000\n10101\n2\n01\n01\n6\n000000\n111110\n", "output": "8\n9\n2\n11\n"}]}
{"statement": "Task: Given a list of n juices, each with a price and a set of vitamins it contains, find the minimum total price of juices that Petya has to buy to obtain all three types of vitamins. Petya needs at least one juice containing each of the vitamins to obtain it.\n\nInput: The first line of input contains an integer n, representing the number of juices. The following n lines contain an integer ci and a string si, representing the price and the set of vitamins contained in the ith juice. The string si contains one to three characters, and the characters are either \"A\", \"B\", or \"C\". Each letter appears at most once in each string si.\n\nOutput: If it is impossible to obtain all three vitamins, print -1. Otherwise, print the minimum total price of juices that Petya has to buy to obtain all three vitamins.\n\nConstraints: 1 \u2264 n \u2264 1,000, 1 \u2264 ci \u2264 100,000.", "editorial": "", "tag": "['Dynamic programming', 'Bit manipulation', 'Implementation', 'Complete search']", "difficulties": "EASY", "source": "codeforces", "url": "https://codeforces.com/problemset/problem/1042/B", "sample_test_cases": [{"input": "4\n5 C\n6 B\n16 BAC\n4 A\n", "output": "15\n"}, {"input": "2\n10 AB\n15 BA\n", "output": "-1\n"}, {"input": "5\n10 A\n9 BC\n11 CA\n4 A\n5 B\n", "output": "13\n"}, {"input": "6\n100 A\n355 BCA\n150 BC\n160 AC\n180 B\n190 CA\n", "output": "250\n"}, {"input": "2\n5 BA\n11 CB\n", "output": "16\n"}]}
{"statement": "Task: Given an integer $n$, determine whether it can be expressed as a sum of a certain number of $2020$ and a certain number of $2021$.\n\nInput: The input consists of multiple test cases. The first line of each test case contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. Each of the following $t$ lines contains an integer $n$ ($1 \\leq n \\leq 10^6$) \u2014 the number that needs to be expressed as the sum of $2020$ and $2021$. The input is read from standard input.\n\nOutput: For each test case, output a single line containing either \"YES\" if the given number $n$ can be expressed as a sum of a certain number of $2020$ and a certain number of $2021$, or \"NO\" otherwise. The output is written to standard output.\n\nConstraints: Each test case has an integer $n$ such that $1 \\leq n \\leq 10^6$.", "editorial": "", "tag": "['Dynamic programming', 'Mathematics', 'Complete search']", "difficulties": "EASY", "source": "codeforces", "url": "https://codeforces.com/problemset/problem/1475/B", "sample_test_cases": [{"input": "5\n1\n4041\n4042\n8081\n8079\n", "output": "NO\nYES\nYES\nYES\nNO\n"}, {"input": "1\n2020\n", "output": "YES\n"}, {"input": "3\n2020\n2021\n4040\n", "output": "YES\nYES\nYES\n"}, {"input": "1\n2021\n", "output": "YES\n"}, {"input": "1\n4040\n", "output": "YES\n"}]}
{"statement": "Task: Implement a memoization solution to optimize the calculation of Fibonacci numbers. The goal is to keep using the tree recursion algorithm while avoiding the inefficiencies of recalculating Fibonacci numbers. The solution involves storing Fibonacci numbers in a cache data structure and looking them up before recalculating. The task is to refactor the function into a recursive Fibonacci function that uses a memoized data structure.\n\nInput: The input for the function is not relevant to the problem statement, as the function is already provided. However, it is mentioned that the input is not used in the memoization solution. Input arrives from standard input.\n\nOutput: The function should return the Fibonacci number for a given input.\n\nConstraints: There are no input constraints mentioned in the problem statement.", "editorial": "", "tag": "['Dynamic programming']", "difficulties": "EASY", "source": "codewars", "url": "https://www.codewars.com/kata/529adbf7533b761c560004e5", "sample_test_cases": [{"input": [70], "output": [190392490709135]}, {"input": [60], "output": [1548008755920]}, {"input": [50], "output": [12586269025]}]}
{"statement": "Task: Given an integer N, find the first N Fibonacci numbers. The first two numbers of the series are 1 and 1.\n\nInput: The input consists of a single integer N, which represents the number of Fibonacci numbers to be found. The input is provided through standard input.\n\nOutput: The output should be a list of the first N Fibonacci numbers. The output should be printed to standard output.\n\nConstraints: The input integer N is constrained to be between 1 and 84, inclusive. \n\nMathematical Concepts: Fibonacci numbers, integer sequences.\n\nComputer Science Concepts: Standard input and output, time and space complexity, algorithm design.", "editorial": "", "tag": "['Dynamic programming', 'Mathematics']", "difficulties": "EASY", "source": "geeksforgeeks", "url": "https://practice.geeksforgeeks.org/problems/print-first-n-fibonacci-numbers1002/1", "sample_test_cases": [{"input": "N = 5", "output": "1 1 2 3 5"}, {"input": "N = 7", "output": "1 1 2 3 5 8 13"}]}
{"statement": "Task: Given two arrays A and B of positive integers of size N and M where N >= M, the task is to maximize the dot product by inserting zeros in the second array but you cannot disturb the order of elements.\n\nInput: The input consists of two arrays A and B of positive integers of size N and M where N >= M. The input is received from standard input.\n\nOutput: The output is the maximum dot product achievable.\n\nConstraints: 1 \u2264 M \u2264N \u2264 10^{3} and 1 \u2264 A[i], B[i] \u2264 10^{3}.\n\nExplanation: Given two arrays A and B of size N and M respectively, the task is to maximize the dot product of the two arrays by inserting zeros in the second array without changing the order of its elements. The dot product of two arrays A and B of size N is defined as A[0]*B[0] + A[1]*B[1]+....A[N]*B[N]. The input consists of two arrays A and B of positive integers of size N and M where N >= M. The output is the maximum dot product achievable. The input is received from standard input. The input constraints are 1 \u2264 M \u2264N \u2264 10^{3} and 1 \u2264 A[i], B[i] \u2264 10^{3}.", "editorial": "", "tag": "['Dynamic programming']", "difficulties": "EASY", "source": "geeksforgeeks", "url": "https://practice.geeksforgeeks.org/problems/maximize-dot-product2649/1", "sample_test_cases": [{"input": "N = 5, A[] = {2, 3, 1, 7, 8} \n       M = 3, B[] = {3, 6, 7}", "output": "107"}, {"input": "N = 3, A[] = {1, 2, 3}\n       M = 1, B[] = {4}", "output": "12"}]}
{"statement": "Task: Given a person standing at X=0 on a number line and allowed to jump either 2 or 3 steps with given probabilities, find the probability that the person will reach X=N.\n\nInput: The input consists of two integers N and P, where N is the final position and P is the probability of jumping 2 steps. The input is provided through standard input.\n\nOutput: The output must be a floating-point number with exactly 6 digits after the decimal point, representing the probability that the person will reach X=N.\n\nConstraints: 0 < N \u2264 10^6 and 0 \u2264 P \u2264 100.\n\nExplanation: We can represent the problem as a directed graph, where each vertex represents a position on the number line and each edge represents a valid jump from one position to another. The person can jump from vertex i to vertex i+2 or i+3 with probabilities P/100 and (100-P)/100, respectively. The task is to find the probability of reaching vertex N starting from vertex 0.\n\nTo solve the problem, we can use dynamic programming. We can define dp[i] as the probability of reaching vertex i starting from vertex 0. We can initialize dp[0] = 1 and dp[i] = 0 for all i \u2260 0. Then, for each vertex i, we can compute dp[i] as the sum of probabilities of reaching vertex i-2 and i-3, weighted by the probabilities of jumping from i-2 and i-3 to i, respectively. Finally, the answer to the problem is dp[N].\n\nThe input consists of T test cases, where each test case contains two integers N and P. The output should consist of T lines, each containing the probability of reaching vertex N for the corresponding test case, with exactly 6 digits after the decimal point. The constraints are 1 \u2264 T \u2264 10^3, 0 < N \u2264 10^6, and 0 \u2264 P \u2264 100.", "editorial": "", "tag": "['Dynamic programming', 'Probability']", "difficulties": "EASY", "source": "hackerearth", "url": null, "sample_test_cases": [{"input": "29210 37", "output": "1.000000"}, {"input": "999996 0", "output": "1.000000"}, {"input": "1000000 100", "output": "0.334448"}, {"input": "1000000 99", "output": "0.465116"}, {"input": "29240 85", "output": "0.497512"}]}
{"statement": "Task: Given an array A of size N, convert it into a special array by rearranging its elements. In the special array, all negative values appear at the beginning and all positive values form the tail of the array. Find the minimum number of values that should be changed in the given array to make it a special array. \n\nInput: The input consists of T test cases. Each test case begins with an integer N, followed by N space-separated integers denoting the elements of the array A. \n\nOutput: For each test case, output a single integer representing the minimum number of changes required to convert the corresponding input array into a special array.\n\nConstraints: 1 \u2264 T \u2264 10, 2 \u2264 N \u2264 10^5, 1 \u2264 |Ai| \u2264 10^9, where || denotes the absolute value. The special array must contain at least one negative and one positive value, and should not contain 0.", "editorial": "", "tag": "['Dynamic programming']", "difficulties": "EASY", "source": "hackerearth", "url": null, "sample_test_cases": []}
{"statement": "Task: Given an integer n, find the value of the nth number in the Tribonacci sequence. The Tribonacci sequence is defined as Tn = Tn-1 + Tn-2 + Tn-3, with T0 = 0, T1 = 1, and T2 = 1.\n\nInput: The input consists of a single integer n, representing the index of the Tribonacci sequence. The input is provided through standard input.\n\nOutput: The output should be a single integer, representing the value of the Tribonacci sequence at index n.\n\nConstraints: The input integer n must satisfy the constraint 0 <= n <= 37. The output integer is guaranteed to fit within a 32-bit integer.", "editorial": "", "tag": "['Dynamic programming', 'Mathematics']", "difficulties": "EASY", "source": "leetcode", "url": "https://leetcode.com/problems/n-th-tribonacci-number/", "sample_test_cases": [{"input": [4], "output": 4}]}
